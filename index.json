[{"categories":["知识点"],"content":"LaTeX ","date":"2022-04-19","objectID":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["latex","数学"],"title":"LaTeX学习笔记","uri":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["知识点"],"content":"1.latex的结构 % 导言区 \\documentclass{article} %一种文档类，也可以是book,report,letter \\usepackage{ctex} %使用中文包 \\title{My First Document} %文章的标题 \\author{Y tq} %文章的作者 \\date{\\today} %文档的时间，today表示今天 % 正文区（文稿区） \\begin{document} %环境名称 \\maketitle %输出标题,letter类没有maketitle Hello World! %空一行表示产生新的段落,多个空行看做一个空行,\\\\表示换行 Let $f(x)$ be defined by the formula $$f(x)=3x^2+x-1$$. % $ $内表示行内公式 $$ $$表示行公式 \\end{document} eg: \\documentclass{article} \\usepackage{ctex} \\title{\\heiti 第一次使用latex} \\author{\\kaishu 于天祺} \\date{\\today} \\begin{document} \\maketitle Hello World \\LaTeX. Let $f(x)$ be defined by the formula $$f(x)=3x^2+x-1$$. 勾股定理可以用现代语言表述如下： 直角三角形斜边的平方等于两腰的平方和。 可以用符号语言表述为：设直角三角形 $ABC$, 其中 $\\angleC=90^\\circ$,则有： \\begin{equation} AB^2 = BC^2 + AC^2. \\end{equation} \\end{document} ","date":"2022-04-19","objectID":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["latex","数学"],"title":"LaTeX学习笔记","uri":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["知识点"],"content":"2.字体设置 \\documentclass[10pt]{article} \\usepackage{ctex} \\newcommand{\\myfont}{\\textit{\\textbf{\\textsf}}} \\begin{document} %字体族设置（罗马字体，无衬线字体，打字机字体） \\textrm{Roman Family} \\textsf{Sans Serif} \\texttt{Typerwriter Family} %这种是声明大括号内的字体 \\rmfamily Roman Family {\\sffamily Sans Serif} {\\ttfamily Typewriter Family} %这种是声明命令之后的字体，大括号对文本分组限定命令作用的范围 %字体系列设置（粗细，宽度） \\textmd{Medium Series} \\textbf{Boldface Series} {\\mdseries Medium Serises} {\\bfseries Boldface Series} %字体形状设置（直立，斜体，伪斜体，小型大写） \\textup{Upright Shape} \\textit{Italic Shape} \\textsl{Slanted Shape} \\textsc{Small Caps Shape} {\\upshape Upright Shape} {\\itshape Italic Shape} {\\slshape Slanted Shape} {\\scshape Small Caps Shape} %中文字体 \\quad是空格 {\\songti 宋体} \\quad {\\heiti 黑体} \\quad {\\fangsong 仿宋} \\quad {\\kaishu 楷书} 中文字体的\\textbf{粗体}与\\textit{斜体} %字体大小 {\\tiny hello}\\\\ {\\scriptsize hello}\\\\ {\\footnotesize hello}\\\\ {\\small hello}\\\\ {\\normalsize hello}\\\\ {\\large hello}\\\\ {\\Large hello}\\\\ {\\LARGE hello}\\\\ {\\huge hello}\\\\ {\\Huge hello}\\\\ %双斜杠是换行 %中文自豪设置命令 \\zihao{-0} 你好! \\end{document} ","date":"2022-04-19","objectID":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["latex","数学"],"title":"LaTeX学习笔记","uri":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["知识点"],"content":"3.文档的基本结构 \\documentclass{article} \\usepackage{ctex} \\begin{document} %构建提纲 \\section{引言} \\section{试验方法} \\chapter{绪论} %chapter（章节）只在book类型中有 \\section{研究的目的和意义} \\section{国内外研究现状} \\subsection{国内研究现状} \\subsection{国外研究现状} \\section{研究内容} \\section{研究方法与技术路线} \\subsection{研究内容} \\subsection{技术路线} \\chapter{试验与结果分析} \\section{引言} \\section{试验方法} \\section{试验结果} \\subsection{数据} \\subsection{图表} \\subsubsection{试验条件} \\subsubsection{试验过程} \\subsection{结果分析} \\section{结论} \\section{致谢} \\end{document} ","date":"2022-04-19","objectID":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["latex","数学"],"title":"LaTeX学习笔记","uri":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["知识点"],"content":"4.特殊字符 \\documentclass{article} \\usepackage{ctex} \\begin{document} %空白字符 \\quad \\+空格 %待添加。。。 \\end{document} ","date":"2022-04-19","objectID":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["latex","数学"],"title":"LaTeX学习笔记","uri":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["知识点"],"content":"5.插入图片 \\documentclass{article} \\usepackage{ctex} \\usepackage{graphicx} %使用此宏包实现插图 \\graphicspath{{figures/},{pics/}} %图片在当前路径下的figure目录，指定图片搜索路径,可以分组！！一定是两个大括号 \\begin{document} \\includegraphics[选项]{文件名} % 格式 EPS,PDF,PNG,JPEG,BMP 选项： scale=0.3 缩放因子 height=2cm 图像高度 width=2cm 图像宽度 height=0.1\\textheight 原文本高度的0.1倍的高度 width=0.2\\textwidth angle=-45 旋转角度 参数间用逗号分隔 \\end{document} ","date":"2022-04-19","objectID":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["latex","数学"],"title":"LaTeX学习笔记","uri":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["知识点"],"content":"6.表格 \\documentclass{article} \\usepackage{ctex} \\begin{document} \\begin{tabular}{|l||c|c|c|p{1.5cm}|} %l,c,r，左，中，右，对齐方式，|添加分隔线p产生指定宽度的表列，会自动换行 \\hline 姓名 \u0026 语文 \u0026 数学 \u0026 外语 \u0026 备注\\\\ \\hline \\hline 张三 \u0026 87 \u0026 100 \u0026 93 \u0026 优秀\\\\ \\hline 李四 \u0026 75 \u0026 64 \u0026 52 \u0026 补考另行通知\\\\ \\hline 王二 \u0026 80 \u0026 82 \u0026 78 \u0026 \\\\ \\hline \\end{tabular} \\end{document} ","date":"2022-04-19","objectID":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["latex","数学"],"title":"LaTeX学习笔记","uri":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["知识点"],"content":"7.浮动体 相当于在文字流中浮动 \\documentclass{article} \\usepackage{ctex} \\usepackage{graphicx} \\begin{document} 爆炒溜肥肠成本见图\\ref{fig-fwih} \\begin{figure}[htbp] \\centering %使浮动内容居中 \\includegraphics[scale=0.3]{feichang} \\caption{爆炒肥肠}\\label{fig-fwih} %图片设置标题，也可适用于table中 \\end{figure} 当然，也可以在\\LaTeX{}中使用表\\ref{tab-score} \\begin{table}[htbp] \\centering \\caption{考试成绩单}\\label{tab-score} \\begin{tabular}{|l||c|c|c|p{1.5cm}|} %l,c,r，左，中，右，对齐方式，|添加分隔线p产生指定宽度的表列，会自动换行 \\hline 姓名 \u0026 语文 \u0026 数学 \u0026 外语 \u0026 备注\\\\ \\hline \\hline 张三 \u0026 87 \u0026 100 \u0026 93 \u0026 优秀\\\\ \\hline 李四 \u0026 75 \u0026 64 \u0026 52 \u0026 补考另行通知\\\\ \\hline 王二 \u0026 80 \u0026 82 \u0026 78 \u0026 \\\\ \\hline \\end{tabular} \\end{table} % figure 使图片浮动，tabular使表格浮动 \\end{document} ","date":"2022-04-19","objectID":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["latex","数学"],"title":"LaTeX学习笔记","uri":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["知识点"],"content":"8.数学公式初步 LaTeX将排版内容分为文本模式和数学模式，文本模式用于普通文本排版，数学模式用于数学公式排版 1.行内公式 ​ 1.$ a+b=b+a $ (a+b=b+a) math环境：\\begin{math}a+b=b+a\\end{math} 2.上下标： $3x^2-x+2=0,3x^{20}-x+2=0,3x^{a+b}$ $a_0+a_1+a_{3+2x^2}$ 3.希腊字母 $\\alpha,\\beta,\\gamma,\\epsilon,\\pi,\\omega,\\Gamma,\\Delta$ $\\Theta,\\Pi,\\Omega$ $\\alpha^3+\\beta^2+\\gamma$ 4.数学函数 $\\log,\\log^2_3,\\log_3^2$ $\\sin,\\cos,\\sin^2x+\\cos^2x=1$ $\\arcsin,\\arccos$ $\\ln$ $\\sqrt2,\\sqrt{x^2+y^2},\\sqrt{2+\\sqrt2},\\sqrt[4]3$ $3/4,\\frac34,\\frac{x}{x^2+x+1},\\frac{\\sqrt{x-1}}{\\sqrt{x+1}},\\frac{1}{1+\\frac{1}{x}},\\sqrt{\\frac{x}{x^2+x+1}}$ 5.行间公式 ​ $$ a+b=b+a $$ [a+b=b+a] (注意：中括号左右都有反斜杠！) \\begin{displaymath}1+2=3\\end{displaymath} 6.自动编号公式 交换律公式：\\ref{eq:commutative} \\begin{equation} ​ a+b=b+a \\label{eq:commutative}(标签) \\end{equation} ","date":"2022-04-19","objectID":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","tags":["latex","数学"],"title":"LaTeX学习笔记","uri":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["知识点"],"content":"9.数学矩阵 \\documentclass{article} \\usepackage{ctex} \\usepackage{amsmath} \\begin{document} % 矩阵环境，\u0026符号分隔列，\\\\符号分隔行 \\[\\begin{matrix} 0\u00261\\\\1\u00260\\end{matrix}\\qquad\\begin{pmatrix} 0\u00261\\\\1\u00260\\end{pmatrix}\\qquad\\begin{bmatrix} 0\u00261\\\\1\u00260\\end{bmatrix}\\qquad\\begin{Bmatrix} 0\u00261\\\\1\u00260\\end{Bmatrix}\\qquad\\begin{vmatrix} 0\u00261\\\\1\u00260\\end{vmatrix}\\qquad\\begin{Vmatrix} 0\u00261\\\\1\u00260\\end{Vmatrix}\\qquad\\] \\[A =\\begin{pmatrix} a_{11}^2\u0026 a_{12}^2\u0026a_{13}^2\\\\0\u0026 a_{22} \u0026 a_{23} \\\\0\u0026 0\u0026 a_{33} \\end{pmatrix} \\] %矩阵中常用省略号 \\dots,\\vdots,\\ddots \\[A =\\begin{bmatrix} a_{11} \u0026 \\dots\u0026a_{1n} \\\\\u0026\\ddots\u0026 \\vdots\\\\0\u0026 \u0026 a_{nn} \\end{bmatrix}_{n \\timesn} \\] %分块矩阵（矩阵嵌套） \\[\\begin{pmatrix} \\begin{matrix} 1\u00260\\\\0\u00261\\end{matrix} \u0026 \\text{\\Large0}\\\\\\text{\\Large0} \u0026 \\begin{matrix} 1\u00260\\\\0\u0026-1\\end{matrix} \\end{pmatrix} \\] \\[\\begin{pmatrix} a_{11} \u0026 a_{12} \u0026 \\cdots\u0026a_{1n}\\\\\u0026a_{22}\u0026 \\cdots\u0026 a_{2n}\\\\\u0026 \u0026 \\ddots\u0026 \\vdots\\\\\\multicolumn{2}{c}{\\raisebox{1.3ex}[0pt]{\\Huge0}} \u0026 \u0026a_{nn} \\end{pmatrix} \\] % 跨列省略号：\\hdotsfor{columns} \\[\\begin{pmatrix} 1\u0026 \\frac12\u0026 \\dots\u0026 \\frac1n\\\\\\hdotsfor{4}\\\\m \u0026 \\fracm2\u0026 \\dots\u0026 \\fracmn \\end{pmatrix} \\] %行内小矩阵 (smallmatrix) 环境 复数 $z =(x,y)$ 也可以用矩阵 \\begin{math} \\left(% 需要手动加上左括号 \\begin{smallmatrix} x \u0026 -y \\\\ y \u0026 x \\end{smallmatrix} \\right)% \\end{math}来表示。 % array环境（类似于表格环境tabular） \\[\\begin{array}{r|r} \\frac12\u0026 0\\\\\\hline0\u0026 -\\fracabc \\\\\\end{array} \\] % % 用array环境构造复杂矩阵 % \\[ % % @{\u003c内容\u003e}-添加任意内容，不占表项技术 % % 此处添加一个负值空白，表示向左移 -5pt的距离 % \\begin{array}{c@{\\hspace{-5pt}}l} % %第一行，第一列 % \\left( % \\begin{array}{ccc|ccc} % a \u0026 \\cdots \u0026 a \u0026 b \u0026 \\cdots \u0026 b\\\\ % \u0026 \\ddots \u0026 \\vdots \u0026 \\vdots \u0026 \\\\ % \u0026 \u0026 a \u0026 b \\\\ \\hline % \u0026 \u0026 \u0026 \\vdots \u0026 \u0026 \\vdots\\\\ % \\multicolumn{2}{c|}{\\raisebox{2ex}[0pt]{\\Huge 0}} % \u0026 c \u0026 \\cdots \u0026 c % \\end{array} % \\right) % \\end{array} % % % \\] \\end{document} ","date":"2022-04-19","objectID":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:0","tags":["latex","数学"],"title":"LaTeX学习笔记","uri":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["知识点"],"content":"10.数学公式的多行公式 \\documentclass{article} \\usepackage{ctex} \\usepackage{amsmath} \\usepackage{amssymb} \\begin{document} \\begin{gather} %带编号,\\notag组织编号 a+b = b+a\\\\ ab = ba \\notag \\\\ a^b \\end{gather} \\begin{gather*} %不带编号 3+5=8\\\\ 3 \\times 5 = 15 \\end{gather*} %align 和 aligh* 环境(用\u0026进行对齐,\u0026的位置代表公式对齐的位置！) \\begin{align} x \u0026=t + \\cos t + 1\\\\ y \u0026=2\\sin t \\end{align} \\begin{align*} x \u0026= t \u0026 x \u0026= \\cos t \u0026 x \u0026= t \\\\ y \u0026= 2t \u0026 y \u0026= \\sin(t+1) \u0026 y \u0026= \\sin t \\end{align*} % split 环境 （对齐采用 align 环境的方式，编号在中间） \\begin{equation} \\begin{split} \\cos 2x \u0026= \\cos^2 x - \\sin^2 x \\\\ \u0026= 2\\cos^2 x - 1 \\end{split} \\end{equation} % cases环境 % 每行公式中使用 \u0026 分隔为两部分， % 通常表示值和后面的条件 \\begin{equation} D(x) = \\begin{cases} 1, \u0026 \\text{如果 } x \\in \\mathbb{Q}; \\\\ 0, \u0026 \\text{如果 } x \\in \\mathbb{R}\\setminus \\mathbb{Q}. \\end{cases} % 一定要使用text命令实现文本模式，实现中文排版， \\end{equation} \\end{document} ","date":"2022-04-19","objectID":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:10:0","tags":["latex","数学"],"title":"LaTeX学习笔记","uri":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["知识点"],"content":"11.自定义命令和环境 \\newcommand\u003c命令\u003e[\u003c参数个数\u003e][\u003c参数默认值\u003e]{\u003c具体定义\u003e} eg: \\newcommand\\PRC{People`s Republic of \\emph{China}} % \\newcommand也可以使用参数 % 参数个数可以从1到9，使用时用 #1,#2,......,#9 表示 eg: \\newcommand\\lovexs[2]{#1 喜欢 #2} \\newcommand\\hatedby[2]{#2 不受 #1 喜欢} \\loves{猫}{鱼} \\hatedby{狗}{萝卜} % \\newcommand的参数也可以有默认值 % 指定参数格式的同时指定了首个参数的默认值，那么这个命令的 % 第一个参数就成为可选的参数(要使用中括号指定) eg: \\newcommand[3][喜欢]{#2#1#3} % \\renewcommand-重新定义已有的命令 % 与\\newcommand 命令作用和用法相同，但只能用于已有的命令 % \\renewcommand\u003c命令\u003e[\u003c参数个数\u003e][\u003c参数默认值\u003e]{\u003c具体定义\u003e} eg: \\renewcommand\\abstractname{内容简介} % 该命令会被abstract环境自动调用 %定义和重新定义环境 % \\newenvironment{\u003c环境名称\u003e}[\u003c参数个数\u003e][\u003c首参数默认值\u003e]{\u003c环境前定义\u003e}{\u003c环境后定义\u003e} % \\renewenvironment{\u003c环境名称\u003e}[\u003c参数个数\u003e][\u003c首参数默认值\u003e]{\u003c环境前定义\u003e}{\u003c环境后定义\u003e} ","date":"2022-04-19","objectID":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:0","tags":["latex","数学"],"title":"LaTeX学习笔记","uri":"/latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"连续序列的最大子列和 给定N个整数的序列${A_1,A_2,\\cdots,A_N}$ 求函数$f(i,j)=max{0,\\sum_{k=i}^nA_n},k=i$的最大值 #include \u003cstdio.h\u003eint MaxSub(int a[],int n){ int i; int sum=0,maxsum=0; for (i=0;i\u003cn;i++){ sum+=a[i]; if(sum\u003emaxsum) maxsum=sum; else if(sum\u003c0) sum=0; } return maxsum; } int main(){ int a[9] = {1,2,3,4,5,6,7,8,9}; int max = MaxSub(a,9); printf(\"%d\",max); return 0; } 最优算法，时间复杂度为$O_{(n)}$ 从头开始，加和小于零置零，确保抛弃段每一段都不可能增加后面最大值 ","date":"2022-04-19","objectID":"/%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C/:0:0","tags":["算法"],"title":"连续序列的最大子列和","uri":"/%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C/"},{"categories":["算法"],"content":"分而治之 折半处理 再次化简$\\Rightarrow NO_{(1)} + O_{nlog_n}$ 最后时间复杂度就是$O_{nlog_n}$ ","date":"2022-04-19","objectID":"/%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C/:1:0","tags":["算法"],"title":"连续序列的最大子列和","uri":"/%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C/"},{"categories":["算法"],"content":"算法基础课相关代码模板 不得不说AcWing真的很良心！2021年春天我补寒假每日一题的一个月真的很充实，也学到了很多东西，但是由于考研就停止每日一题了，打算日子稳定之后再把它拾起来。 ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/:0:0","tags":["算法","c++"],"title":"常用代码2","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/"},{"categories":["算法"],"content":"快速排序算法模板 —— 模板题 AcWing 785. 快速排序 void quick_sort(int q[], int l, int r) { if (l \u003e= r) return; int i = l - 1, j = r + 1, x = q[l + r \u003e\u003e 1]; while (i \u003c j) { do i ++ ; while (q[i] \u003c x); do j -- ; while (q[j] \u003e x); if (i \u003c j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/:1:0","tags":["算法","c++"],"title":"常用代码2","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/"},{"categories":["算法"],"content":"归并排序算法模板 —— 模板题 AcWing 787. 归并排序 void merge_sort(int q[], int l, int r) { if (l \u003e= r) return; int mid = l + r \u003e\u003e 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u003c= mid \u0026\u0026 j \u003c= r) if (q[i] \u003c= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i \u003c= mid) tmp[k ++ ] = q[i ++ ]; while (j \u003c= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i \u003c= r; i ++, j ++ ) q[i] = tmp[j]; } ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/:2:0","tags":["算法","c++"],"title":"常用代码2","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/"},{"categories":["算法"],"content":"整数二分算法模板 —— 模板题 AcWing 789. 数的范围 bool check(int x) {/* ... */} // 检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) { while (l \u003c r) { int mid = l + r \u003e\u003e 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; } return l; } // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： int bsearch_2(int l, int r) { while (l \u003c r) { int mid = l + r + 1 \u003e\u003e 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/:3:0","tags":["算法","c++"],"title":"常用代码2","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/"},{"categories":["算法"],"content":"浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根 bool check(double x) {/* ... */} // 检查x是否满足某种性质 double bsearch_3(double l, double r) { const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l \u003e eps) { double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } return l; } ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/:4:0","tags":["算法","c++"],"title":"常用代码2","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/"},{"categories":["算法"],"content":"高精度加法 —— 模板题 AcWing 791. 高精度加法 // C = A + B, A \u003e= 0, B \u003e= 0 vector\u003cint\u003e add(vector\u003cint\u003e \u0026A, vector\u003cint\u003e \u0026B) { if (A.size() \u003c B.size()) return add(B, A); vector\u003cint\u003e C; int t = 0; for (int i = 0; i \u003c A.size(); i ++ ) { t += A[i]; if (i \u003c B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if (t) C.push_back(t); return C; } ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/:5:0","tags":["算法","c++"],"title":"常用代码2","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/"},{"categories":["算法"],"content":"高精度减法 —— 模板题 AcWing 792. 高精度减法 // C = A - B, 满足A \u003e= B, A \u003e= 0, B \u003e= 0 vector\u003cint\u003e sub(vector\u003cint\u003e \u0026A, vector\u003cint\u003e \u0026B) { vector\u003cint\u003e C; for (int i = 0, t = 0; i \u003c A.size(); i ++ ) { t = A[i] - t; if (i \u003c B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t \u003c 0) t = 1; else t = 0; } while (C.size() \u003e 1 \u0026\u0026 C.back() == 0) C.pop_back(); return C; } ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/:6:0","tags":["算法","c++"],"title":"常用代码2","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/"},{"categories":["算法"],"content":"高精度乘低精度 —— 模板题 AcWing 793. 高精度乘法 // C = A * b, A \u003e= 0, b \u003e 0 vector\u003cint\u003e mul(vector\u003cint\u003e \u0026A, int b) { vector\u003cint\u003e C; int t = 0; for (int i = 0; i \u003c A.size() || t; i ++ ) { if (i \u003c A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; } while (C.size() \u003e 1 \u0026\u0026 C.back() == 0) C.pop_back(); return C; } ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/:7:0","tags":["算法","c++"],"title":"常用代码2","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/"},{"categories":["算法"],"content":"高精度除以低精度 —— 模板题 AcWing 794. 高精度除法 // A / b = C ... r, A \u003e= 0, b \u003e 0 vector\u003cint\u003e div(vector\u003cint\u003e \u0026A, int b, int \u0026r) { vector\u003cint\u003e C; r = 0; for (int i = A.size() - 1; i \u003e= 0; i -- ) { r = r * 10 + A[i]; C.push_back(r / b); r %= b; } reverse(C.begin(), C.end()); while (C.size() \u003e 1 \u0026\u0026 C.back() == 0) C.pop_back(); return C; } ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/:8:0","tags":["算法","c++"],"title":"常用代码2","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/"},{"categories":["算法"],"content":"一维前缀和 —— 模板题 AcWing 795. 前缀和 S[i] = a[1] + a[2] + ... a[i] a[l] + ... + a[r] = S[r] - S[l - 1] ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/:9:0","tags":["算法","c++"],"title":"常用代码2","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/"},{"categories":["算法"],"content":"二维前缀和 —— 模板题 AcWing 796. 子矩阵的和 S[i, j] = 第i行j列格子左上部分所有元素的和 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1] ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/:10:0","tags":["算法","c++"],"title":"常用代码2","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/"},{"categories":["算法"],"content":"一维差分 —— 模板题 AcWing 797. 差分 给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/:11:0","tags":["算法","c++"],"title":"常用代码2","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/"},{"categories":["算法"],"content":"二维差分 —— 模板题 AcWing 798. 差分矩阵 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/:12:0","tags":["算法","c++"],"title":"常用代码2","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/"},{"categories":["算法"],"content":"位运算 —— 模板题 AcWing 801. 二进制中1的个数 求n的第k位数字: n \u003e\u003e k \u0026 1 返回n的最后一位1：lowbit(n) = n \u0026 -n ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/:13:0","tags":["算法","c++"],"title":"常用代码2","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/"},{"categories":["算法"],"content":"双指针算法 —— 模板题 AcWIng 799. 最长连续不重复子序列, AcWing 800. 数组元素的目标和 for (int i = 0, j = 0; i \u003c n; i ++ ) { while (j \u003c i \u0026\u0026 check(i, j)) j ++ ; // 具体问题的逻辑 } 常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/:14:0","tags":["算法","c++"],"title":"常用代码2","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/"},{"categories":["算法"],"content":"离散化 —— 模板题 AcWing 802. 区间和 vector\u003cint\u003e alls; // 存储所有待离散化的值 sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素 // 二分求出x对应的离散化的值 int find(int x) // 找到第一个大于等于x的位置 { int l = 0, r = alls.size() - 1; while (l \u003c r) { int mid = l + r \u003e\u003e 1; if (alls[mid] \u003e= x) r = mid; else l = mid + 1; } return r + 1; // 映射到1, 2, ...n } ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/:15:0","tags":["算法","c++"],"title":"常用代码2","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/"},{"categories":["算法"],"content":"区间合并 —— 模板题 AcWing 803. 区间合并 // 将所有存在交集的区间合并 void merge(vector\u003cPII\u003e \u0026segs) { vector\u003cPII\u003e res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for (auto seg : segs) if (ed \u003c seg.first) { if (st != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else ed = max(ed, seg.second); if (st != -2e9) res.push_back({st, ed}); segs = res; } ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/:16:0","tags":["算法","c++"],"title":"常用代码2","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%812/"},{"categories":["算法"],"content":"c++常用函数 ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/:0:0","tags":["算法","c++"],"title":"常用代码","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/"},{"categories":["算法"],"content":"b进制转换 char get(int x)//将x转换为字符形式 { if (x \u003c= 9) return x + '0'; return x - 10 + 'A'; } string base(int n, int b)//将n转换为b进制，返回对应字符串 { string res; while (n) { res += get(n % b); n /= b; } reverse(res.begin(), res.end());//翻转回高位在左 return res; } ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/:1:0","tags":["算法","c++"],"title":"常用代码","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/"},{"categories":["算法"],"content":"dfs void dfs(int x,int y) { g[x][y]='#'; cnt++; for(int i=0;i\u003c4;i++) { int a=x+dx[i],b=y+dy[i]; if(a\u003c0 || a\u003e=n || b\u003c0 || b\u003e=m || g[a][b]=='#') continue; dfs(a,b); } } ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/:2:0","tags":["算法","c++"],"title":"常用代码","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/"},{"categories":["算法"],"content":"bfs #include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003calgorithm\u003e #define x first #define y second using namespace std; typedef pair\u003cint,int\u003e PII; const int N = 25; int n,m; char g[N][N]; int bfs(int sx,int sy){ queue\u003cPII\u003e q; q.push({sx,sy}); g[sx][sy] = '#'; int res = 0; int dx[] = {-1,0,1,0},dy[] = {0,1,0,-1}; //重点 ，四个方向，上，右，下，左 while(q.size()){ auto t = q.front(); q.pop(); res++; for(int i=0;i\u003c4;i++){ int x = t.x + dx[i],y = t.y + dy[i]; if(x\u003c0||x\u003e=n||y\u003c0||y\u003e=m||g[x][y]!='.') continue; g[x][y] = '#'; q.push({x,y}); } } return res; } ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/:3:0","tags":["算法","c++"],"title":"常用代码","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/"},{"categories":["算法"],"content":"最小上升子序列（dp） #include \u003ciostream\u003e using namespace std; const int N = 1010; int n; int w[N], f[N]; int main() { cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) cin \u003e\u003e w[i]; int mx = 1; // 找出所计算的f[i]之中的最大值，边算边找 for (int i = 0; i \u003c n; i++) { f[i] = 1; // 设f[i]默认为1，找不到前面数字小于自己的时候就为1 for (int j = 0; j \u003c i; j++) { if (w[i] \u003e w[j]) f[i] = max(f[i], f[j] + 1); // 前一个小于自己的数结尾的最大上升子序列加上自己，即+1 } mx = max(mx, f[i]); } cout \u003c\u003c mx \u003c\u003c endl; return 0; } ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/:4:0","tags":["算法","c++"],"title":"常用代码","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/"},{"categories":["算法"],"content":"下一排列 w[], 1-n next_permutation int k = n; while(w[k-1]\u003ew[k]) k--; //找到反向升序列的第一个位置（从后往前） int t = k; while(w[t+1]\u003ew[k-1]) t++; //再反向升序列中找到比第一个位置的前一个位置的值大的最小值得位置 swap(w[k-1],w[t]); reverse(w+k,w+n+1); ","date":"2022-04-19","objectID":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/:5:0","tags":["算法","c++"],"title":"常用代码","uri":"/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/"},{"categories":null,"content":"刷题技巧 记录c++刷题过程中的技巧 ","date":"2022-04-19","objectID":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/:0:0","tags":["算法"],"title":"刷题技巧","uri":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"vector ​ vector\u003c类型\u003e标识符(最大容量，初始所有值) vector\u003cvector\u003cint\u003e \u003e cnt(m, vector\u003cint\u003e(5)); stoi(字符串(str),起始位置(0),n进制(2)) //将字符串转为十进制数参数为const string int atoi(const char *str) 参数为const char* ","date":"2022-04-19","objectID":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/:1:0","tags":["算法"],"title":"刷题技巧","uri":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"多项选择判断 a,b,c,d,e建立hash表 hash[] = {1,2,4,8,16} //a1,b10,c100,d1000,e10000 ^ 异或，判断学生选项与正确选项是否相同，哪道题错，哪位是1 | 或，判断是否没选全，学生答案填上正确选项位，如果和正确选项一致，那么说明学生只是漏选 \u0026 与，与每个选项计算，判断哪个选项选错 int temp; scanf(\"(%d\", \u0026temp); for (int k = 0; k \u003c temp; k++) { char c; scanf(\" %c)\", \u0026c); cout\u003c\u003cc\u003c\u003cendl; } ","date":"2022-04-19","objectID":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/:2:0","tags":["算法"],"title":"刷题技巧","uri":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"string string (长度，赋值) ","date":"2022-04-19","objectID":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/:3:0","tags":["算法"],"title":"刷题技巧","uri":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"cctype头文件的使用 参数为字符 函数名 返回值 isalnum() 如果参数是字母数字，即字母或者数字，函数返回true isalpha() 如果参数是字母，函数返回true iscntrl() 如果参数是控制字符，函数返回true isdigit() 如果参数是数字（0－9），函数返回true isgraph() 如果参数是除空格之外的打印字符，函数返回true islower() 如果参数是小写字母，函数返回true isprint() 如果参数是打印字符（包括空格），函数返回true ispunct() 如果参数是标点符号，函数返回true isspace() 如果参数是标准空白字符，如空格、换行符、水平或垂直制表符，函数返回true isupper() 如果参数是大写字母，函数返回true isxdigit() 如果参数是十六进制数字，即0－9、a－f、A－F，函数返回true tolower() 如果参数是大写字符，返回其小写，否则返回该参数 toupper() 如果参数是小写字符，返回其大写，否则返回该参数 ","date":"2022-04-19","objectID":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/:4:0","tags":["算法"],"title":"刷题技巧","uri":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"很绝的代码 B1084 #include \u003ciostream\u003eusing namespace std; int main() { string s; int n, j; cin \u003e\u003e s \u003e\u003e n; for (int cnt = 1; cnt \u003c n; cnt++) { string t; for (int i = 0; i \u003c s.length(); i = j) { for (j = i; j \u003c s.length() \u0026\u0026 s[j] == s[i]; j++); ///注意这里,其实就是一个判断 t += s[i] + to_string(j - i); } s = t; } cout \u003c\u003c s; return 0; } ","date":"2022-04-19","objectID":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/:5:0","tags":["算法"],"title":"刷题技巧","uri":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"map迭代器的访问遍历 int main(){ map\u003cint, string\u003emp; mp[3] = \"asdf\"; mp[5] = \"zxcv\"; mp[4] = \"xvzcv\"; for(auto it = mp.begin();it!=mp.end();it++){ cout\u003c\u003cit-\u003esecond\u003c\u003cendl; } return 0; } ","date":"2022-04-19","objectID":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/:6:0","tags":["算法"],"title":"刷题技巧","uri":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"使用 i\u003ca\u0026\u0026i\u003cb 取最小值,i\u003ca||i\u003cb 取最大值 c++各变量取值大小 type min max unsigned int 0 4294967295 int -2147483648(2^31) 2147483647 unsigned long 0 4294967295 long -2147483648 2147483647 long long -9223372036854775807(2^63) 9223372036854775808 unsigned long long 18446744073709551615 __int64的最大值 -9223372036854775808 9223372036854775807 unsigned __int64的最大值 18446744073709551615 数据类型 32位 64位 取值范围 char 1 1 -128~127 ","date":"2022-04-19","objectID":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/:7:0","tags":["算法"],"title":"刷题技巧","uri":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"反向迭代,最大元素 string str = \"1234567890\"; for(auto it = str.rbegin();it!=str.rend();it++){ cout\u003c\u003c*it; } cout\u003c\u003c*max_element(str.begin(),str.end()); //按字典序 ","date":"2022-04-19","objectID":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/:8:0","tags":["算法"],"title":"刷题技巧","uri":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"pat甲级有疑问的 1012 1044 ","date":"2022-04-19","objectID":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/:9:0","tags":["算法"],"title":"刷题技巧","uri":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"常用的代码 //判断是否是素数 bool isPrime(int a){ if(a\u003c=1) return false; float tmp = (int)sqrt(a*1.0); for(int i=2;i\u003c=tmp;i++){ if(a%i==0) return false; } return true; } 二次探测法 hash(key) = (key%m+d)%m === (key+d)%m; (d=1^2,-1^2,2^2,-2^2,……); 查找次数小于m. 待补充。。 ","date":"2022-04-19","objectID":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/:10:0","tags":["算法"],"title":"刷题技巧","uri":"/%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/"},{"categories":["知识点"],"content":"markdown数学符号 ^表示上标， $$ a^1 $$ _表示下标， $$ x_1 $$ 如果上（下）标内容多于一个字符就需要使用{}，注意不是( ), 因为( )经常是公式本身组成部分，为避免冲突，所以选用了{ } 将其包起来。 $$ x^{y^z}=(1+e^x)^{-2xy^w} $$ 效果：xyz=(1+ex)−2xyw 上面输入的上下标都是在字符的右侧，要想在左侧或者两侧都写上下标，那么需要使用\\sideset语法。 $$ \\sideset{12}{^3_4}\\bigotimes $$ 效果：12⨂34 ","date":"2022-04-19","objectID":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:0:0","tags":["工具","markdown"],"title":"Markdown数学符号","uri":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["知识点"],"content":"3.3 括号和分隔符 ( )和[ ]就是自身了，由于{ } 是Tex的元字符，所以表示它自身时需要转义。 示例： $$ f(x,y) = x^2 + y^2, x\\epsilon[0,100] $$ 效果：f(x,y)=x2+y2,xϵ[0,100] 有时候括号需要大号的，普通括号不好看，此时需要使用\\left和\\right加大括号的大小。 示例： $$ (\\frac{x}{y})^8，\\left(\\frac{x}{y}\\right)^8 $$ 效果：(xy)8，(xy)8 \\left和\\right必须成对出现，对于不显示的一边可以使用 . 代替。 示例： $$ $$ $$ \\left.\\frac{{\\rm d}u}{{\\rm d}x} \\right| _{x=0} $$ 效果：dudx∣∣x=0 ","date":"2022-04-19","objectID":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:1:0","tags":["工具","markdown"],"title":"Markdown数学符号","uri":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["知识点"],"content":"3.4 分数 使用\\frac{分子}{分母}格式，或者 分子\\over 分母。 示例： $$ \\frac{1}{2x+1}或者 $$ $$ 1\\over{2x+1} $$ 效果：12x+1或者12x+1 ","date":"2022-04-19","objectID":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:2:0","tags":["工具","markdown"],"title":"Markdown数学符号","uri":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["知识点"],"content":"3.5 开方 示例： $$ \\sqrt[9]{3}和\\sqrt{3} $$ 效果：3‾‾√9 和 3‾‾√ ","date":"2022-04-19","objectID":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:3:0","tags":["工具","markdown"],"title":"Markdown数学符号","uri":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["知识点"],"content":"3.6 省略号 有两种省略号，\\ldots 表示语文本底线对其的省略号，\\cdots表示与文本中线对其的省略号。 示例： $$ f(x_1, x_2, \\ldots, x_n)=x_1^2 + x_2^2+ \\cdots + x_n^2 $$ 效果：f(x1,x2,…,xn)=x21+x22+⋯+x2n ","date":"2022-04-19","objectID":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:4:0","tags":["工具","markdown"],"title":"Markdown数学符号","uri":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["知识点"],"content":"3.7 矢量 示例： $$ \\vec{a} \\cdot \\vec{b}=0 $$ 效果: a⃗ ⋅b⃗ =0 ","date":"2022-04-19","objectID":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:5:0","tags":["工具","markdown"],"title":"Markdown数学符号","uri":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["知识点"],"content":"3.8 积分 示例： $$ \\int_0^1x^2{\\rm d}x $$ 效果： ∫10x2dx ","date":"2022-04-19","objectID":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:6:0","tags":["工具","markdown"],"title":"Markdown数学符号","uri":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["知识点"],"content":"3.9 极限 示例： $$ \\lim_{n\\rightarrow+\\infty}\\frac{1}{n(n+1)} $$ 效果： limn→+∞1n(n+1) ","date":"2022-04-19","objectID":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:7:0","tags":["工具","markdown"],"title":"Markdown数学符号","uri":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["知识点"],"content":"3.10 累加、累乘 示例： $$ \\sum_1^n\\frac{1}{x^2}，\\prod_{i=0}^n\\frac{1}{x^2} $$ 效果：∑n11x2， ∏ni=01x2 ","date":"2022-04-19","objectID":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:8:0","tags":["工具","markdown"],"title":"Markdown数学符号","uri":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["知识点"],"content":"3.11 希腊字母 希腊字符示例： $$ \\alpha A　\\beta B　\\gamma \\Gamma \\delta\\Delta　\\epsilon　E \\varepsilon　\\zeta　Z　\\eta　H　\\theta　\\Theta　\\vartheta \\iota　I $$ $$ \\kappa　K　\\lambda　\\Lambda　\\mu　M　\\nu　N \\xi　\\Xi　o　O　\\pi　\\Pi　\\varpi　\\rho　P \\varrho　\\sigma　\\Sigma　$$ $$ \\varsigma　\\tau　T　\\upsilon　\\Upsilon \\phi　\\Phi　\\varphi　\\chi　X　\\psi　\\Psi　\\omega　\\Omega $$ 效果： α　A　β　B　γ　Γ　δ　Δ　ϵ　Eε　ζ　Z　η　H　θ　Θ　ϑι　I　κ　K　λ　Λ　μ　M　ν　Nξ　Ξ　o　O　π　Π　ϖ　ρ　Pϱ　σ　Σ　ς　τ　T　υ　Υϕ　Φ　φ　χ　X　ψ　Ψ　ω　Ω ","date":"2022-04-19","objectID":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:9:0","tags":["工具","markdown"],"title":"Markdown数学符号","uri":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["知识点"],"content":"3.12 数学符号大汇总 ± ：\\pm × ：\\times ÷：\\div ∣：\\mid $$ \\pm \\times \\div \\mid fsf\\mid $$ ⋅：\\cdot ∘：\\circ ∗: \\ast ⨀：\\bigodot ⨂：\\bigotimes ⨁：\\bigoplus ≤：\\leq ≥：\\geq ≠：\\neq ≈：\\approx ≡：\\equiv ∑：\\sum ∏：\\prod ∐：\\coprod ","date":"2022-04-19","objectID":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:10:0","tags":["工具","markdown"],"title":"Markdown数学符号","uri":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["知识点"],"content":"集合运算符： ∅：\\emptyset ∈：\\in ∉：\\notin ⊂：\\subset ⊃ ：\\supset ⊆ ：\\subseteq ⊇ ：\\supseteq ⋂ ：\\bigcap ⋃ ：\\bigcup ⋁ ：\\bigvee ⋀ ：\\bigwedge ⨄ ：\\biguplus ⨆：\\bigsqcup 对数运算符： log ：\\log lg ：\\lg ln ：\\ln 三角运算符： ⊥：\\bot ∠：\\angle 30∘：30^\\circ sin ：\\sin cos ：\\cos tan ：\\tan cot ：\\cot sec ：\\sec csc ：\\csc 微积分运算符： y′x：\\prime ∫：\\int ∬ ：\\iint ∭ ：\\iiint ⨌：\\iiiint ∮ ：\\oint lim ：\\lim ∞ ：\\infty ∇：\\nabla ","date":"2022-04-19","objectID":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:10:1","tags":["工具","markdown"],"title":"Markdown数学符号","uri":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["知识点"],"content":"逻辑运算符： ∵：\\because ∴ ：\\therefore ∀ ：\\forall ∃ ：\\exists ≠ ：\\not= ≯：\\not\u003e ⊄：\\not\\subset ","date":"2022-04-19","objectID":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:10:2","tags":["工具","markdown"],"title":"Markdown数学符号","uri":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["知识点"],"content":"戴帽符号： ŷ ：\\hat{y} yˇ：\\check{y} y˘：\\breve{y} ","date":"2022-04-19","objectID":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:10:3","tags":["工具","markdown"],"title":"Markdown数学符号","uri":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["知识点"],"content":"连线符号： a+b+c+d⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯：\\overline{a+b+c+d} a+b+c+d⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯：\\underline{a+b+c+d} a+b+c⏟1.0+d2.0：\\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0} $$ \\underline{a+b+c+d} $$ $$ \\overline{a+b+c+d} $$ $$ \\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0} $$ ","date":"2022-04-19","objectID":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:10:4","tags":["工具","markdown"],"title":"Markdown数学符号","uri":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["知识点"],"content":"箭头符号： ↑：\\uparrow ↓：\\downarrow ⇑ ：\\Uparrow ⇓：\\Downarrow →：\\rightarrow ← ：\\leftarrow ⇒ ：\\Rightarrow ⇐ ：\\Leftarrow ⟶ ：\\longrightarrow ⟵ ：\\longleftarrow ⟹：\\Longrightarrow ⟸ ：\\Longleftarrow ","date":"2022-04-19","objectID":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:10:5","tags":["工具","markdown"],"title":"Markdown数学符号","uri":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["知识点"],"content":"3.13 需要转义的字符 要输出字符　空格　#　$　%　\u0026　_　{　}　，用命令：　\\空格　#　$　%　\u0026　_　{　} ","date":"2022-04-19","objectID":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:11:0","tags":["工具","markdown"],"title":"Markdown数学符号","uri":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["知识点"],"content":"3.14 使用指定字体 {\\rm text}如： 使用罗马字体：text text 其他的字体还有： \\rm　罗马体　\\it　意大利体 \\bf　黑体　\\cal 花体 \\sl　倾斜体　\\sf　等线体 \\mit 数学斜体　\\tt　打字机字体 \\sc　小体大写字母 ${\\ masdf}$ 居中 删除线 [希腊字母](## 逻辑运算符:) a = [] print(a) 功夫不是一天练成的 asfd asdfa 你可以使用脚注像这样1 :athletic_shoe: :smile: :+1: :cry: :dash: :heart: :kissing_heart: :wea :weary: :star: 比方说这里是2 分隔线 ==发赛风== asdf adfasdf asdfasfd 下划线 :a: :baby_bottle: 返回目录 这里写脚注的文本 ↩︎ 这里是1说的内容 ↩︎ ","date":"2022-04-19","objectID":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:12:0","tags":["工具","markdown"],"title":"Markdown数学符号","uri":"/markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":["技术"],"content":"git的使用方法 ","date":"2022-04-19","objectID":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["git","linux","工具"],"title":"Git学习笔记","uri":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["技术"],"content":"基本命令 暂存区(将你的工作结果暂时保存,以便对比) git add \\\\添加到暂存区 git status \\\\查看状态 git diff \\\\查看修改后的文件和暂存区的区别 git restore filename \\\\恢复文件到暂存区的状态(丢弃工作区的改动) git restore --staged filename \\\\取消文件在暂存区(无论是删除还是多次修改,状态均为未提交,) HEAD(指向你最后一次提交的结果,相当于游戏里的存档)当前版本 git commit -m \"提交的信息\" -a 可以将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过git add添加到暂存区(新添加的文件不可以提交到仓库,建议不使用 -a) --amend 追加提交(在不增加一个新的commid-id的情况下) git log 查看提交日志 --pretty=online 一行展示 short 简短展示 git log --graph --pretty=oneline --abbrev-commit git reset HEAD^ 回退到上一个版本 HEAD^^ 上上一个版本 HEAD~100 上一百个版本 git reflog 查看每一次的commit命令(意味着查看到版本号就可以回到相应的版本去) git checkout -- filename 撤销文件在工作区的修改 git rm filename 删除并且git add 远程仓库 git remote add origin git@github.com:peapio/gittest.git // 关联到远程仓库 git push origin master master不存在,将会新建 $ git push origin :master # 等同于 $ git push origin --delete master 表示删除master分支,相当于推送空的本地文件到远程分支 如果当前分支和远程分支存在追踪关系,则本地分支和远程分支都可以省略 git push -u origin master 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。 ","date":"2022-04-19","objectID":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["git","linux","工具"],"title":"Git学习笔记","uri":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["技术"],"content":"ssh key的添加 ","date":"2022-04-19","objectID":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["git","linux","工具"],"title":"Git学习笔记","uri":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["技术"],"content":"1.设置git的username和email git config --global user.name \"peapio\" git config --global user.email \"aqiiii@yeah.net\" //github对应数据 git config -l查看当前配置 git config color.ui true git提示更明显 ","date":"2022-04-19","objectID":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:1","tags":["git","linux","工具"],"title":"Git学习笔记","uri":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["技术"],"content":"2.检查是否存在SSH Key cd .ssh ll //查看是否有 id_rsa 和 id_rsa.pub 如果存在说明有SSH Key ","date":"2022-04-19","objectID":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:2","tags":["git","linux","工具"],"title":"Git学习笔记","uri":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["技术"],"content":"3.生成SSH Key ssh-keygen -t rsa -C \"aqiiii@yeah.net\" enter cat id_rsa.pub //复制密钥 ","date":"2022-04-19","objectID":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:3","tags":["git","linux","工具"],"title":"Git学习笔记","uri":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["技术"],"content":"4.GitHub添加SSH Key 设置-\u003eSSH ","date":"2022-04-19","objectID":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:4","tags":["git","linux","工具"],"title":"Git学习笔记","uri":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["技术"],"content":"5.验证和修改 sh -T git@github.com //运行结果出现类似如下 Hi peapio! You've successfully authenticated, but GitHub does not provide shell access. git支持多种协议,包括https,ssh,但ssh协议速度最快 ","date":"2022-04-19","objectID":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:5","tags":["git","linux","工具"],"title":"Git学习笔记","uri":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["技术"],"content":"git分支管理 ","date":"2022-04-19","objectID":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["git","linux","工具"],"title":"Git学习笔记","uri":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["技术"],"content":"创建与合并 git checkout -b dev === git switch -c dev 创建并切换到dev分支 相当于 git branch dev git checkout dev === git switch dev git branch 查看当前分支 git meage dev 当前分支与dev分支合并(该分支变得和dev相同,在本分支没有改变之前时) git merge --no-ff -m \"merge with no-ff\" dev 合并时保留信息,也就是多一个commit git branch -d dev 删除dev分支 git branch -D dev 强制删除(适用于被删除的分支没有被merge) 团队合作时,分支应该看起来这样 ","date":"2022-04-19","objectID":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","tags":["git","linux","工具"],"title":"Git学习笔记","uri":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["技术"],"content":"修复bug分支 git stach 储藏工作现场,以便于需要临时切换到别的分支, git stach list 查看保存的工作现场 git stach apply 恢复 git stach drop 删除 或者 git stach pop 恢复并删除 git stash apply stash@{0} 恢复指定 git cherry-pick 4c805e2 复制一次特定提交到当前分支(用与bug修复) ","date":"2022-04-19","objectID":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:2","tags":["git","linux","工具"],"title":"Git学习笔记","uri":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["技术"],"content":"Feature分支 每添加一个新功能可以新建一个Feature分支 git remote -v 查看远程仓库的信息 ","date":"2022-04-19","objectID":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:3","tags":["git","linux","工具"],"title":"Git学习笔记","uri":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["技术"],"content":"git标签 git tag \u003cname\u003e git tag 查看所有标签 git tag -d v1.0 删除标签 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 git push origin \u003ctagname\u003e 推送某个标签到远程 git oush origin --tags 推送所有未推送到远程的本地标签 git push origin :refs/tags/\u003ctagname\u003e 删除一个远程标签 git tag \u003cname\u003e \u003ccommitid\u003e 为忘记打标签的提交打标签 git show \u003ctagname\u003e 查看标签提交详细内容 git tag -a \u003ctagname\u003e -m \"content\" \u003ccommit_id :heavy_exclamation_mark:注意,标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 ","date":"2022-04-19","objectID":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:4","tags":["git","linux","工具"],"title":"Git学习笔记","uri":"/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["英语"],"content":"记录不会的计算机专用词汇 ","date":"2022-04-19","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87/:0:0","tags":["英语"],"title":"计算机刷题常用英语词汇","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87/"},{"categories":["英语"],"content":"PTA甲级刷题时不理解词汇 记录在刷题过程中遇到的不会的单词 英文 汉语 digits 数字,位数 Specification 规范 commas 逗号 that is 也就是说 positive numbers 正数 A request list is made up with N positive numbers. 请求列表由N个正数组成。 denote\u001c 表示 polynomials 多项式 nonzero terms 非零项 exponents 指数 coefficients 系数 respectively 分别地 NO extra space 没有多余空格 Please be accurate to 1 decimal place 请精确到小数点后一位 scattered 疏散,分散 respectively 分别地 i-th 第i个 guaranteed 保证地 non-negative integer 非负整数 consecutive 连续的 generate 生成 corresponding 相应 capital English letter 大写英文字母 representing 代表 Scientific notation 科学计数法 notation 符号 matches 匹配,火柴 regular expression 正则表达式 integer portion 整数部分 fractional portion 小数部分 sentence ending particles 句子结尾词 particles 颗粒,粒子 notorious 臭名昭著 stereotype 刻板印象 inclusive 包括的 suffix 后缀 prefix 前缀 Product of Polynomials 多项式的乘除 simulate 模拟 permutation 排列,组合 corresponding 相应的 Lottery 彩票,抽奖 distinct 清晰的,不同的 equation 方程 all the solutions must be printed in increasing order of i. 所有结果将会以i升序打印 chronologically 按时间排序 For the sake of simplicity 为了简单起见 Insertion sort iterates 插入排序迭代 subsequence 子序列 segment 段,部分,分割 radix 基数 reversible 可逆的 negative 负 大二的时候本来打算考一下PTA，可是由于种种原因（最主要的原因还是我自己😅），最后还是没有去考，现在再看这些词，虽然没有仔细背过，但是居然大部分我都认得了，也许当时再坚持一下，现在的情况可能也不会这么糟糕了🤔 待补充。。 ","date":"2022-04-19","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87/:1:0","tags":["英语"],"title":"计算机刷题常用英语词汇","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87/"},{"categories":["算法"],"content":"【DP专辑】ACM动态规划总结 ","date":"2022-04-19","objectID":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/:0:0","tags":["动态规划"],"title":"【DP专辑】ACM动态规划总结","uri":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"闫式DP分析法 置顶 Accagain 2014-05-15 13:43:46 19565 收藏 99 分类专栏： 动态规划 版权 转载请注明出处，谢谢。 http://blog.csdn.net/cc_again?viewmode=list ———- Accagain 2014年5月15日 动态规划一直是ACM竞赛中的重点，同时又是难点，因为该算法时间效率高，代码量少，多元性强，主要考察思维能力、建模抽象能力、灵活度。 本人动态规划博客地址：http://blog.csdn.net/cc_again/article/category/1261899 ==动态规划==（英语：Dynamic programming，DP）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 **动态规划问题满足三大重要性质 ** ==最优子结构性质==：如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。 ==子问题重叠性质==：子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。 ==无后效性==：将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。 动态规划分类有很多划分方法，网上有很多是按照状态来分，分为一维、二维、区间、树形等等。我觉得还是按功能即解决的问题的类型以及难易程度来分比较好，下面按照我自己的理解和归纳，把动态规划的分类如下： ","date":"2022-04-19","objectID":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/:1:0","tags":["动态规划"],"title":"【DP专辑】ACM动态规划总结","uri":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"一、简单基础dp 这类dp主要是一些状态比较容易表示，转移方程比较好想，问题比较基本常见的。主要包括递推、背包、LIS（最长递增序列），LCS（最长公共子序列），下面针对这几种类型，推荐一下比较好的学习资料和题目。 ","date":"2022-04-19","objectID":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/:2:0","tags":["动态规划"],"title":"【DP专辑】ACM动态规划总结","uri":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"1、递推： 递推一般形式比较单一，从前往后，分类枚举就行。 简单: hdu 2084 数塔 简单从上往下递推 hdu 2018 母牛的故事 简单递推计数 hdu 2044 一只小蜜蜂… 简单递推计数（Fibonacci） hdu 2041 超级楼梯 Fibonacci hdu 2050 折线分割平面 找递推公式 推荐： CF 429B B.Working out 四个角递推 zoj 3747 Attack on Titans 带限制条件的计数递推dp uva 10328 Coin Toss 同上题 hdu 4747 Mex hdu 4489 The King’s Ups and Downs hdu 4054 Number String ","date":"2022-04-19","objectID":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/:2:1","tags":["动态规划"],"title":"【DP专辑】ACM动态规划总结","uri":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"2、背包 经典的背包九讲：http://love-oriented.com/pack/ 推荐博客：http://blog.csdn.net/woshi250hua/article/details/7636866 主要有==0-1背包==、==完全背包==、==分组背包==、==多重背包==。 简单： hdu 2955 Robberies 01背包 hdu 1864 最大报销额 01背包 hdu 2602 Bone Collector 01背包 hdu 2844 Coins 多重背包 hdu 2159 FATE 完全背包 推荐： woj 1537 A Stone-I 转化成背包 woj 1538 B Stone-II 转化成背包 poj 1170 Shopping Offers 状压+背包 zoj 3769 Diablo III 带限制条件的背包 zoj 3638 Fruit Ninja 背包的转化成组合数学 hdu 3092 Least common multiple 转化成完全背包问题 poj 1015 Jury Compromise 扩大区间+输出路径 poj 1112 Team Them UP 图论+背包 ","date":"2022-04-19","objectID":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/:2:2","tags":["动态规划"],"title":"【DP专辑】ACM动态规划总结","uri":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"3、LIS 最长递增子序列，朴素的是o(n^2)算法，二分下可以写成o(nlgn)：维护一个当前最优的递增序列——找到恰好大于它更新 简单： hdu 1003 Max Sum hdu 1087 Super Jumping! 推荐： uva 10635 Prince and Princess LCS转化成LIS hdu 4352 XHXJ’s LIS　数位dp+LIS思想 srm div2 1000 状态压缩+LIS poj 1239 Increasing Sequence 两次dp 4、LCS 最长公共子序列，通常o(n^2)的算法 hdu 1503 Advanced Fruits hdu 1159 Common Subsequence uva 111 History Grading 要先排个序 poj 1080 Human Gene Functions ","date":"2022-04-19","objectID":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/:2:3","tags":["动态规划"],"title":"【DP专辑】ACM动态规划总结","uri":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"二、区间dp 推荐博客：http://blog.csdn.net/woshi250hua/article/details/7969225 区间dp,一般是枚举区间，把区间分成左右两部分，然后求出左右区间再合并。 poj 1141 Brackets Sequence 括号匹配并输出方案 hdu 4745 Two Rabbits 转化成求回文串 zoj 3541 The Last Puzzle 贪心+区间dp poj 2955 Brackets hdu 4283 You Are the One 常见写法 hdu 2476 String Printer zoj 3537 Cake CF 149D Coloring Brackets zoj 3469 Food Delivery ","date":"2022-04-19","objectID":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/:3:0","tags":["动态规划"],"title":"【DP专辑】ACM动态规划总结","uri":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"三、树形dp 比较好的博客：http://blog.csdn.net/woshi250hua/article/details/7644959 一篇论文：http://doc.baidu.com/view/f3b19d0b79563c1ec5da710e.html 树形dp是建立在树这种数据结构上的dp,一般状态比较好想，通过dfs维护从根到叶子或从叶子到根的状态转移。 hdu 4123 Bob’s Race 二分+树形dp+单调队列 hdu 4514 求树的直径 poj 1655 Balancing Act hdu 4714 Tree2Cycle 思维 hdu 4616 Game hdu 4126 Genghis Kehan the Conqueror MST+树形dp 比较经典 hdu 4756 Install Air Conditioning MST+树形dp 同上 hdu 3660 Alice and Bob’s Trip 有点像对抗搜索 CF 337D Book of Evil 树直径的思想 思维 hdu 2196 Computer 搜两遍 ","date":"2022-04-19","objectID":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/:4:0","tags":["动态规划"],"title":"【DP专辑】ACM动态规划总结","uri":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"四、数位dp 推荐一篇论文：http://wenku.baidu.com/view/d2414ffe04a1b0717fd5dda8.html 数位dp,主要用来解决统计满足某类特殊关系或有某些特点的区间内的数的个数，它是按位来进行计数统计的，可以保存子状态，速度较快。数位dp做多了后，套路基本上都差不多，关键把要保存的状态给抽象出来，保存下来。 hdu 2089 不要62 简单数位dp hdu 3709 Balanced Number 比较简单 CF 401D Roman and Numbers 状压+数位dp hdu 4398 X mod f(x) 把模数加进状态里面 hdu 4734 F(x) 简单数位dp hdu 3693 Math teacher’s homework 思维变换的数位dp hdu 4352 XHXJ’s LIS　数位dp+LIS思想 CF 55D Beautiful Numbers 比较巧妙的数位dp hdu 3565 Bi-peak Numbers 比较难想 CF 258B Little Elephant and Elections 数位dp+组合数学+逆元 ","date":"2022-04-19","objectID":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/:5:0","tags":["动态规划"],"title":"【DP专辑】ACM动态规划总结","uri":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"五、概率(期望) dp 推荐博客：http://www.cnblogs.com/kuangbin/archive/2012/10/02/2710606.html 推荐博客：http://blog.csdn.net/woshi250hua/article/details/7912049 推荐论文： 《走进概率的世界》 《浅析竞赛中一类数学期望问题的解决方法》 《有关概率和期望问题的研究》 一般来说概率正着推，期望逆着推。有环的一般要用到高斯消元解方程。**期望可以分解成多个子期望的加权和，权为子期望发生的概率，即 $ E(aA+bB+…) = aE(A) + bE(B) +… $ ** ural 1776 Anniversiry Firework 比较基础 hdu 4418 Time travel 比较经典BFS+概率dp+高斯消元 hdu 4586 Play the Dice 推公式比较水 hdu 4487 Maximum Random Walk jobdu 1546 迷宫问题 高斯消元+概率dp+BFS预处理 hdu 3853 LOOPS 简单概率dp hdu 4405 Aeroplane chess 简单概率dp,比较直接 hdu 4089 Activation 比较经典 poj 2096 Collecting Bugs 题目比较难读懂 zoj 3640 Help me Escape 从后往前，比较简单 hdu 4034 Maze 经典好题，借助树的概率dp hdu 4336 Card Collector 状态压缩+概率dp hdu 4326 Game 这个题状态有点难抽象 ","date":"2022-04-19","objectID":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/:6:0","tags":["动态规划"],"title":"【DP专辑】ACM动态规划总结","uri":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"六、状态压缩dp 这类问题有TSP、插头dp等。 推荐论文：http://wenku.baidu.com/view/ce445e4f767f5acfa1c7cd51.html 推荐博客：http://blog.csdn.net/sf____/article/details/15026397 推荐博客：http://www.notonlysuccess.com/index.php/plug_dp/ hdu 1693 Eat the Trees 插头dp hdu 4568 Hunter 最短路+TSP hdu 4539 插头dp hdu 4529 状压dp poj 1185 炮兵阵地 poj 2411 Mandriann’s Dream 轮廓线dp hdu 3811 Permutation poj 1038 poj 2441 hdu 2167 hdu 4026 hdu 4281 ","date":"2022-04-19","objectID":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/:7:0","tags":["动态规划"],"title":"【DP专辑】ACM动态规划总结","uri":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"七、数据结构优化的dp 有时尽管状态找好了，转移方程的想好了，但时间复杂度比较大，需要用数据结构进行优化。常见的优化有二进制优化、单调队列优化、斜率优化、四边形不等式优化等。 ","date":"2022-04-19","objectID":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/:8:0","tags":["动态规划"],"title":"【DP专辑】ACM动态规划总结","uri":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"1、二进制优化 主要是优化背包问题，背包九讲里面有介绍，比较简单，这里只附上几道题目。 hdu 1059 Diving hdu 1171 Big Event in Hdu poj 1048 Follow My Magic ","date":"2022-04-19","objectID":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/:8:1","tags":["动态规划"],"title":"【DP专辑】ACM动态规划总结","uri":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"2、单调队列优化 推荐论文：http://wenku.baidu.com/view/4d23b4d128ea81c758f578ae.html 推荐博客：http://www.cnblogs.com/neverforget/archive/2011/10/13/ll.html hdu 3401 Trade poj 3245 Sequece Partitioning 二分+单调队列优化 ","date":"2022-04-19","objectID":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/:8:2","tags":["动态规划"],"title":"【DP专辑】ACM动态规划总结","uri":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"3、斜率优化 推荐论文：用单调性优化动态规划 推荐博客：http://www.cnblogs.com/ronaflx/archive/2011/02/05/1949278.html hdu 3507 Print Article poj 1260 Pearls hdu 2829 Lawrence hdu 2993 Max Average Problem ","date":"2022-04-19","objectID":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/:8:3","tags":["动态规划"],"title":"【DP专辑】ACM动态规划总结","uri":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"},{"categories":["算法"],"content":"4、四边形不等式优化 推荐博客：http://www.cnblogs.com/ronaflx/archive/2011/03/30/1999764.html 推荐博客：http://www.cnblogs.com/zxndgv/archive/2011/08/02/2125242.html hdu 2952 Counting Sheep poj 1160 Post Office hdu 3480 Division hdu 3516 Tree Construction hdu 2829 Lawrence ","date":"2022-04-19","objectID":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/:8:4","tags":["动态规划"],"title":"【DP专辑】ACM动态规划总结","uri":"/dp%E4%B8%93%E8%BE%91acm%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"C++STL ","date":"2022-04-19","objectID":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:0:0","tags":["c++"],"title":"C++_STL常用函数","uri":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["编程语言"],"content":"1.vector 向量:长度根据需要自动改变的数组 #include \u003ciostream\u003e#include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cvector\u003eusing namespace std; int main(){ vector\u003cint\u003e name; for(int i=1;i\u003c=5;i++){ name.push_back(i); } name.insert(name.begin()+name.size(),-1); name.erase(first,last); //利用迭代器的两种遍历方式 for(vector\u003cint\u003e::iterator it=name.begin();it!=name.end();it++){ cout\u003c\u003c*it; } vector\u003cint\u003e::iterator it=name.begin(); for(int i=0;i\u003c5;i++){ cout\u003c\u003c*(it+i); } cout\u003c\u003c\"\\n\"\u003c\u003cname.size(); } ","date":"2022-04-19","objectID":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:0","tags":["c++"],"title":"C++_STL常用函数","uri":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["编程语言"],"content":"vector常用函数 方法 时间复杂度 作用 push_back() O(1) 在vector的后面添加一个元素x pop_back() O(1) 删除vector尾元素 size() O(1) 获得vector中元素的个数 clear() O(n) 清除vector中所有元素 insert(it,x) O(n) 像it处插入一个元素x erase(it) O(n) 删除it处的元素 erase(first,last) O(n) 删除区间内的元素,左闭右开 ==作用:动态存储== ","date":"2022-04-19","objectID":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:1","tags":["c++"],"title":"C++_STL常用函数","uri":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["编程语言"],"content":"2.set 集合:内部自动有序且不含重复元素的容器 set不可以*(set++) #include \u003ciostream\u003e#include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cset\u003eusing namespace std; int main(){ set\u003cint\u003e name; name.insert(3); name.insert(5); name.insert(2); name.insert(7); name.insert(4); set\u003cint\u003e::iterator it = name.find(5); name.erase(name.find(5)); name.size(); for(set\u003cint\u003e::iterator it = name.begin();it!=name.end();it++){ cout\u003c\u003c*it; } } ","date":"2022-04-19","objectID":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:2:0","tags":["c++"],"title":"C++_STL常用函数","uri":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["编程语言"],"content":"set常用函数 方法 时间复杂度 作用 insert(x) O(logN) 将x插入到set容器中,并自动递增排序并去重 find(value) O(logN) 返回set中对应值为value的迭代器 erase(it) O(1) 删除单个元素迭代器st.erase(st.find(100)); erase(value) O(logN) 删除单个元素的值,value为确切值 erase(first,last) O(last-first) 参数为迭代器地址,删除区间元素,左闭右开 size() O(1) 获得set内元素个数 clear() O(N) 清空set内所有元素 ==作用:排序去重== ","date":"2022-04-19","objectID":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:2:1","tags":["c++"],"title":"C++_STL常用函数","uri":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["编程语言"],"content":"3.String #include \u003ciostream\u003e#include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cstring\u003eusing namespace std; int main(){ string str = \"gffd\"; for(string::iterator it = str.begin();it != str.end();it++){ cout\u003c\u003c*it; } cout\u003c\u003cstr; printf(\"%s\",str.c_str()); for(int i=0;i\u003cstr.length();i++){ printf(\"%c\",str[i]); } //几种遍历方法 } ","date":"2022-04-19","objectID":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:3:0","tags":["c++"],"title":"C++_STL常用函数","uri":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["编程语言"],"content":"String常用函数 方法 时间复杂度 作用 compare operator 两个字符串可以直接使用==,!=,\u003c,\u003c=等比大小,比较规则是字典序 length()/size() O(1) 返回string的长度 insert(pos,string) O(N) 在pos处插入string,0,1,2,3,第一个字符前是0 insert(it,it2,it3) O(N) it为原字符欲插入位置,it2,it3为待插字符串首尾迭代器 erase(it) O(N) 删除元素迭代器 erase(first,last) O(N) 删除区间,左闭右开 erase(pos,length) O(N) pos为起始位置,length为删除字符个数 clear() O(1) 清空 substr(pos,len) O(len) 返回从pos开始len长的子串 find(str2) O(mn) 返回str第一次出现的位置,否则返回string::npos find(str2,pos) O(mn) 从pos处开始匹配,返回值与上相同 replace(pos,len,str2) O(str.length()) 把从str从pos号位开始长度为len的子串替换为str2 string::npos是一个常数,其本身为-1,但由于是unsigned_int类型,因此也可以认为是unsigned_int的最大值,可等于4294967295string::npos用以作为find函数失配的返回值 n,m分别为str,str2的长度 ","date":"2022-04-19","objectID":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:3:1","tags":["c++"],"title":"C++_STL常用函数","uri":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["编程语言"],"content":"4.map 映射: array[0]=25, 0–\u003e25 0映射到25,map可以将任何基本类型(包括STL容器)映射到任何基本类型(包括STL容器) #include \u003ciostream\u003e#include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cstring\u003e#include \u003cmap\u003e using namespace std; int main(){ map\u003cchar,int\u003e mp; mp['m'] = 20; mp['r'] = 30; mp['a'] = 40; //map\u003cchar,int\u003e::iterator it = mp.begin(); //cout\u003c\u003cit-\u003efirst\u003c\u003cit-\u003esecond\u003c\u003cendl; for(map\u003cchar,int\u003e::iterator it = mp.begin();it!=mp.end();it++){ cout\u003c\u003cit-\u003efirst\u003c\u003cit-\u003esecond\u003c\u003cendl; //打印键和值 } cout\u003c\u003cmp['r']; } map会以键从小到大的顺序自动排序 ","date":"2022-04-19","objectID":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:4:0","tags":["c++"],"title":"C++_STL常用函数","uri":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["编程语言"],"content":"map常用函数 方法 时间复杂度 作用 find(key) O(logN) 返回键为key的映射迭代器 erase(it) O(1) 删除元素的迭代器,mp.erase(mp.find(’d’)); erase(key) O(logN) key为欲删除映射的键 erase(first,last) O(last-first) 删除区间,左闭右开 size() O(1) 获得映射map的对数 clear() O(N) 清除map中所有元素 ","date":"2022-04-19","objectID":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:4:1","tags":["c++"],"title":"C++_STL常用函数","uri":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["编程语言"],"content":"5.queue 队列:先进先出 #include \u003ciostream\u003e#include \u003cstdio.h\u003e#include \u003cqueue\u003eusing namespace std; int main(){ queue\u003cint\u003e q; for(int i=0;i\u003c5;i++){ q.push(i); } cout\u003c\u003cq.front()\u003c\u003cendl; cout\u003c\u003cq.back()\u003c\u003cendl; //输出头和尾 } ","date":"2022-04-19","objectID":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:5:0","tags":["c++"],"title":"C++_STL常用函数","uri":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["编程语言"],"content":"queue常用函数 方法 时间复杂度 作用 push() O(1) 将x入队(尾进) pop() O(1) 出队(头出) empty() O(1) 判空 size() O(1) 返回元素个数 front() O(1) 获取头元素 back() O(1) 获取尾元素 ","date":"2022-04-19","objectID":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:5:1","tags":["c++"],"title":"C++_STL常用函数","uri":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["编程语言"],"content":"6.priority_queue 优先队列:其底层是用堆来实现的,优先队列中队首元素一定是当前队列优先级最高的 优先队列没有front(),back(),只能通过top()函数获取队首元素(对顶元素).也就是优先级最高的元素 ","date":"2022-04-19","objectID":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:6:0","tags":["c++"],"title":"C++_STL常用函数","uri":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["编程语言"],"content":"priority_queue常用函数 方法 时间复杂度 作用 push(x) O(logN) 将x入队 top() O(1) 获取对顶元素(队首元素) empty() O(1) 判空 size() O(1) 返回优先队列元素个数 ","date":"2022-04-19","objectID":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:6:1","tags":["c++"],"title":"C++_STL常用函数","uri":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["编程语言"],"content":"priority_queue内元素优先级的设置 基本数据类型的优先级设置 int,char,double,等数字越大优先级越高(如果是char型,字典序最大) pritority_queue\u003cint\u003e q; pritority_queue\u003cint,vector\u003cint\u003e,less\u003cint\u003e \u003e q; 相比第一种第二种多出两个参数,vector表示承载底层数据结构堆的(heap)容器,==less表示数字大的优先级越大,greater表示数字小的优先级越大== 结构体的优先级设置 struct fruit{ string name; int price; }; 现在希望按水果的价格高的优先级高,需用重载(overload)小于号\"\u003c\".重载是指对已有的运算符进行重新定义,也就是说可以改变小于号的功能 struct fruit { string name; int price; friend bool operator \u003c (fruit f1,fruit f2){ return f1.price\u003cf2.price; } }; friend为友元 重载\u003e号会出错? #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cqueue\u003eusing namespace std; struct fruit{ string name; int price; }f1,f2,f3; struct cmp{ bool operator () (fruit f1,fruit f2){ return f1.price\u003ef2.price; } }; int main(){ pritority_queue\u003cfruit,vector\u003cfruit\u003e,cmp\u003e q; f1.name = \"桃子\"; f1.price = 3; f2.name = \"梨子\"; f2.price = 4; f3.name = \"苹果\"; f3.price = 1; q.push(f1); q.push(f2); q.push(f3); cout\u003c\u003cq.top().name\u003c\u003c\" \"\u003c\u003cq.top().price\u003c\u003cendl; return 0; //第二种方式,常用方式 } ","date":"2022-04-19","objectID":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:6:2","tags":["c++"],"title":"C++_STL常用函数","uri":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["编程语言"],"content":"7.stack 栈:后进后出 #include \u003ciostream\u003e#include \u003cstdio.h\u003e#include \u003cstack\u003eusing namespace std; int main(){ stack\u003cint\u003e st; for(int i=0;i\u003c5;i++){ st.push(i); } cout\u003c\u003cst.top(); } ","date":"2022-04-19","objectID":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:7:0","tags":["c++"],"title":"C++_STL常用函数","uri":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["编程语言"],"content":"stack常用函数 方法 时间复杂度 作用 push() O(1) 入栈 top() O(1) 获得栈顶元素 pop() O(1) 弹出栈顶元素 empty() O(1) 判空 size() O(1) 返回stack内元素的个数 ","date":"2022-04-19","objectID":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:7:1","tags":["c++"],"title":"C++_STL常用函数","uri":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["编程语言"],"content":"8. pair 当需要将两个元素捆绑在一起作为一个合成元素,又不想因此定义一个结构体时,使用pair作为一个替代品. #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cutility\u003e//如果记不住utility可以使用map,因为map实现设计pair using namespace std; int main(){ pair\u003cstring,int\u003e p; p.first = \"haha\"; p.second = 5; cout\u003c\u003c p.first \u003c\u003c\" \"\u003c\u003c p.second\u003c\u003cendl; p = make_pair(\"xixi\",55); cout\u003c\u003c p.first \u003c\u003c\" \"\u003c\u003c p.second\u003c\u003cendl; p = pair\u003cstring,int\u003e(\"heihei\",555); cout\u003c\u003c p.first \u003c\u003c\" \"\u003c\u003c p.second\u003c\u003cendl; //实现Pair的几种方式 } ","date":"2022-04-19","objectID":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:8:0","tags":["c++"],"title":"C++_STL常用函数","uri":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["编程语言"],"content":"pair常用函数 ####　比较操作数 两个ｐａｉｒ类型的数据可以直接使用==,!=,\u003c=,\u003e,\u003e=等比较大小比较规则以first的大小为标准,只有first相等时,才去判断second的大小 ","date":"2022-04-19","objectID":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:8:1","tags":["c++"],"title":"C++_STL常用函数","uri":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["编程语言"],"content":"9.algorithm头文件下的常用函数 方法 作用 max(x,y) 返回x,y中的最大值(可以是浮点数),三个数最大值max(x,max(y,z)) min(x,y) 返回x,y中的最小值(可以是浮点数) abs(x) 返回x的绝对值(必须是正数,浮点数用math下的fabs) swap(x,y) 交换x和y的值 reverse(it,it2) 可将数组指针在[it,it2)之间的元素或容器的迭代器的其范围内的元素进行进行反转 next_permutation() 给出一个序列在全排列中的下一个序列 next_permutation() #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; int main() { int num[3]={1,2,3}; do { cout\u003c\u003cnum[0]\u003c\u003c\" \"\u003c\u003cnum[1]\u003c\u003c\" \"\u003c\u003cnum[2]\u003c\u003cendl; }while(next_permutation(num,num+3)); return 0; } fill():可以把数组或容器中的某一段区间赋为某个相同的值.和memset不同,这里的赋值可以是数组类型对应范围中的任意值 #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int main(){ int a[5] = {1,2,3,4,5}; fill(a,a+5,233); for(int i=0;i\u003c5;i++){ cout\u003c\u003ca[i]; } } sort():用来排序的函数 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; int main() { int a[6] = {9,4,2,5,6,-1}; double b[] = {1.4,-2.1,9}; char c[] = {'T','W','A','K'}; sort(a,a+4); for(int i=0;i\u003c6;i++){ cout\u003c\u003ca[i]; } cout\u003c\u003c\"\\n\"; sort(a,a+6); for(int i=0;i\u003c6;i++){ cout\u003c\u003ca[i]; } cout\u003c\u003c\"\\n\"; sort(b,b+3); for(int i=0;i\u003c3;i++){ cout\u003c\u003cb[i]; } cout\u003c\u003c\"\\n\"; sort(c,c+4); for(int i=0;i\u003c4;i++){ cout\u003c\u003cc[i]; } return 0; } sort有三个参数前两个是容器的首尾迭代器,左闭右开,第三个就是比较函数cmp,不添默认按照从小到大排序 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; template \u003ctypename T\u003e bool cmp(T a,T b){ return a\u003eb; } int main() { int a[6] = {9,4,2,5,6,-1}; double b[] = {1.4,-2.1,9}; char c[] = {'T','W','A','K'}; sort(c,c+3,cmp\u003cchar\u003e); for(int i=0;i\u003c3;i++){ cout\u003c\u003cc[i]; } return 0; } 结构体数组的排序 struct node{ int x,y; }ssd[10]; `` bool cmp(node a,node b){ return a.x\u003eb.x; } `` 容器的排序 #include \u003cstdio.h\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; bool cmp(int a,int b){ return a\u003eb; } int main(){ vector\u003cint\u003e vi; vi.push_back(3); vi.push_back(1); vi.push_back(2); sort(vi.begin(),vi.end(),cmp); for(int i=0;i\u003c3;i++){ printf(\"%d\",vi[i]); } return 0; } `` string的排序 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int main(){ string str[3] = {\"bbbb\",\"cc\",\"aaa\"}; sort(str,str+3); for(int i=0;i\u003c3;i++){ cout\u003c\u003cstr[i]\u003c\u003cendl; } return 0; } `` 按照字符串的从小到大排序 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; bool cmp(string str1,string str2){ return str1.length()\u003cstr2.length(); } int main(){ string str[3] = {\"bbbb\",\"cc\",\"aaa\"}; sort(str,str+3,cmp); for(int i=0;i\u003c3;i++){ cout\u003c\u003cstr[i]\u003c\u003cendl; } return 0; } `` lower_bound()和upper_bound() lower_bound(forst,last,val)用来寻找在数组或容器的[first,lasr)范围内==第一个值大于或等于val的元素的位置==,如果是数组,则返回该位置的指针;如果是容器,则返回该位置的迭代器 upper_bound(forst,last,val)用来寻找在数组或容器的[first,lasr)范围内==第一个值大于val的元素的位置==,如果是数组,则返回该位置的指针;如果是容器,则返回该位置的迭代器 如果数组或容器中没有需要寻找的元素,则均返回可以插入该元素的位置的指针或迭代器(==即假设存在该元素时,该元素应当在的位置==) 时间复杂度均为O(log(last-fast)) #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; int main(){ int a[10] = {1,2,2,3,3,3,5,5,5,5};//注意数组下标从0开始 //寻找-1 int *lowerPos = lower_bound(a,a+10,-1); int *upperPos = upper_bound(a,a+10,-1); cout\u003c\u003clowerPos-a\u003c\u003c\" \"\u003c\u003cupperPos-a\u003c\u003cendl; //寻找1 lowerPos = lower_bound(a,a+10,1); upperPos = upper_bound(a,a+10,1); cout\u003c\u003clowerPos-a\u003c\u003c\" \"\u003c\u003cupperPos-a\u003c\u003cendl; //寻找3 lowerPos = lower_bound(a,a+10,3); upperPos = upper_bound(a,a+10,3); cout\u003c\u003clowerPos-a\u003c\u003c\" \"\u003c\u003cupperPos-a\u003c\u003cendl; //寻找4 lowerPos = lower_bound(a,a+10,4); upperPos = upper_bound(a,a+10,4); cout\u003c\u003clowerPos-a\u003c\u003c\" \"\u003c\u003cupperPos-a\u003c\u003cendl; //寻找6 lowerPos = lower_bound(a,a+10,6); upperPos = upper_bound(a,a+10,6); cout\u003c\u003clowerPos-a\u003c\u003c\" \"\u003c\u003cupperPos-a\u003c\u003cendl; } 如果只想获得欲查询的元素的下标,就可以不用临时指针,而==直接令返回值减去数组首地址即可== ","date":"2022-04-19","objectID":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:9:0","tags":["c++"],"title":"C++_STL常用函数","uri":"/c-_stl%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["技术"],"content":"介绍一下我的neovim配置 ","date":"2022-02-09","objectID":"/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%88%91%E7%9A%84nvim%E9%85%8D%E7%BD%AE/:0:0","tags":["vim","linux"],"title":" 介绍一下我的neovim配置","uri":"/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%88%91%E7%9A%84nvim%E9%85%8D%E7%BD%AE/"},{"categories":["技术"],"content":"附上Pluglist call plug#begin('~/.config/nvim/vim/plugged') \"美化插件 Plug 'hardcoreplayers/spaceline.vim' \" Plug 'itchyny/lightline.vim' \" Plug 'vim-airline/vim-airline' \" Plug 'vim-airline/vim-airline-themes' \" Plug 'liuchengxu/eleline.vim' Plug 'bagrat/vim-buffet' Plug 'luochen1990/rainbow' Plug 'kristijanhusak/vim-hybrid-material' Plug 'hardcoreplayers/oceanic-material' Plug 'mhartington/oceanic-next' Plug 'hardcoreplayers/dashboard-nvim' Plug 'morhetz/gruvbox' \" Plug 'octol/vim-cpp-enhanced-highlight',{'for':'cpp'} \" c++高亮 Plug 'Yggdroot/indentLine' \" 缩进可视化 Plug 'ryanoasis/vim-devicons' \" 给各种插件增加文件图标 Plug 'chrisbra/changesPlugin' \" 文件修改提示 Plug 'itchyny/vim-cursorword' \" 光标在单词上会有一个下划线 Plug 'kristijanhusak/defx-icons' \"功能插件 :使用更顺畅 Plug 'chxuan/vim-edit' Plug 'gcmt/wildfire.vim' \" 智能选中enter Plug 'suan/vim-instant-markdown', {'for': 'markdown'} \" markdown预览 Plug 'dhruvasagar/vim-table-mode', {'on':'TableModeToggle'} \" 更规范的表格 Plug 'kshenoy/vim-signature' \" 书签跳转，ma Plug 'junegunn/vim-easy-align' \" 快速对齐 ,a2\u003cspace\u003e第二个空格对齐，,a-\u003cspace\u003e倒数，,a*\u003cspace\u003e所有，,a\u003cEnter\u003e*\u003cspace\u003e右对齐 Plug 'easymotion/vim-easymotion', {'on':['\u003cPlug\u003e(easymotion-w)','\u003cPlug\u003e(easymotion-b)']} \" 快速移动 Plug 'terryma/vim-smooth-scroll' \" 平滑翻页 Plug 'rhysd/clever-f.vim' \" 智能F，搜索高亮，f跳转 Plug 'rhysd/accelerated-jk' \" 加速jk键 Plug 'tpope/vim-repeat' \" 增强．功能，可以重复surround Plug 'junegunn/vim-slash' \" 搜索后移动取消高亮 Plug 'itchyny/screensaver.vim', {'on': 'ScreenSaver'} \" 屏幕保护程序 Plug 'jiangmiao/auto-pairs' \" 自动补全括号 Plug 'tpope/vim-commentary' \" 注释插件 Plug 'tpope/vim-surround' \" yss\"加＂号，csw'\" ＇修改成＂　ds'删除＇ \" Plug 'vim-scripts/fcitx.vim', {'for': ['markdown','cpp','vim','sh']} \" 切换中文不影响普通模式输入 \" Plug 'vim-scripts/VimIM' Plug 'ZSaberLv0/ZFVimIM' Plug 'ZSaberLv0/ZFVimJob' Plug 'ZSaberLv0/ZFVimGitUtil' \" 可选, 如果你希望定期自动清理词库 push 历史 Plug 'YourUserName/ZFVimIM_pinyin_base' \" 你的词库 Plug 'ZSaberLv0/ZFVimIM_openapi' \" 可选, 百度云输入法 \" 功能插件: Plug 'dense-analysis/ale' \" 错误提示 Plug 'neoclide/coc.nvim', {'branch': 'release'} \" 自动补全 Plug 'honza/vim-snippets' \" 代码片 Plug 'yianwillis/vimcdoc' \" vim中文手册 Plug 'mbbill/undotree', {'on':'UndotreeToggle'} \" 撤销树（代码回滚） Plug 'junegunn/fzf', {'on':['Files', 'History', 'Colors', 'Rg', 'Marks'] } \" fzf模糊查找文件 Plug 'junegunn/fzf.vim', {'on':['Files', 'History', 'Colors', 'Rg', 'Marks']} Plug 'sbdchd/neoformat', {'on':'Neoformat'} \" 格式化文件(我还没用过)leader\u003enf Plug 'voldikss/vim-floaterm', { 'on': 'FloatermNew' } \" 浮动终端 Plug 'liuchengxu/vista.vim', {'on':'Vista'} \" 查看函数什么的 Plug 'kristijanhusak/defx-git', {'on':'Defx'} \" 查看文件树 Plug 'Shougo/defx.nvim', { 'do': ':UpdateRemotePlugins'} Plug 'tyru/open-browser.vim', {'on':['\u003cPlug\u003e(openbrowser-smart-search)', '\u003cPlug\u003e(openbrowser-open)']} \" gx google搜索, gu打开连接 Plug 'mg979/vim-visual-multi', {'branch': 'master'} \" \u003cc-n\u003e 多鼠标操作 Plug 'voldikss/vim-translator', { 'on':'\u003cPlug\u003eTranslate' } \" 划词翻译 leader\u003etl Plug 'junegunn/goyo.vim', {'on':'Goyo'} \" 专注模式gy开启 Plug 'tweekmonster/startuptime.vim', {'on': 'StartupTime'} \" 查看启动所需时间 \" 可选 \"Plug 'sheerun/vim-polyglot',{'for':['c', 'h', 'cpp', 'py', 'go', 'java', 'vim', 'json', 'hs']} \"Plug 'vim-scripts/vim-auto-save' \"Plug 'kien/rainbow_parentheses.vim' \"Plug 'Yggdroot/LeaderF', { 'do': './install.sh' } \" 文件搜索 \"Plug 'wakatime/vim-wakatime' \" 统计代码时间 \"Plug 'SirVer/ultisnips' \"Plug 'rhysd/github-complete.vim' \"Plug 'simnalamburt/vim-mundo' \" 撤销树可视化 call plug#end() ","date":"2022-02-09","objectID":"/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%88%91%E7%9A%84nvim%E9%85%8D%E7%BD%AE/:1:0","tags":["vim","linux"],"title":" 介绍一下我的neovim配置","uri":"/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%88%91%E7%9A%84nvim%E9%85%8D%E7%BD%AE/"},{"categories":["技术"],"content":"StartupTime Total Time: 120.288 – Flawless Victory Slowest 10 plugins (out of 33)~ [runtime] 35.025 [vimrc] 28.422 coc.nvim 10.588 vim-buffet 10.202 vim-visual-multi 5.184 ZFVimJob 4.578 ZFVimIM 4.135 vim-devicons 3.060 vim-signature 2.727 ale 2.355 我的nvim配置地址：https://github.com/peapio/nvim ","date":"2022-02-09","objectID":"/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%88%91%E7%9A%84nvim%E9%85%8D%E7%BD%AE/:2:0","tags":["vim","linux"],"title":" 介绍一下我的neovim配置","uri":"/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%88%91%E7%9A%84nvim%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"Linux文件系统的备份 ​ 最近还是按捺不住自己安装了Manjaro，并且搭配了i3的桌面。由于曾经使用过arch，这一次配置起来倒还是轻车熟路，本打算manjaro只做试验，不做主力系统，所以并没有分配太多磁盘空间（40GB），可是manjaro-i3相比Windows实在是太香，尤其实在我这个好几年前的配置的电脑几乎要带不动win10的情况下，索性打算直接暂用manjaro做学习的主力系统。那么这样的话，40GB的大小就显得不够用了。 ​ 所以我打算先扩展一下磁盘大小，cfdisk发现磁盘好像不能向左扩展，从Windows身上割下来的20G空间无法融入到linux中，遂在网上查找后，发现了gparted好像可以实现我想要的效果，gparted提示磁盘文件有丢失的风险，最好备份谨慎使用，并且基于arch的manjaro同样是滚动更新，多少还是有不稳定的风险，于是我便找起了备份系统的方法。 一番对比之后选择了rsync ","date":"2022-02-09","objectID":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/:0:0","tags":null,"title":"Linux文件系统的备份","uri":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"Rsync的基本特点如下： 可以镜像保存整个目录树和文件系统； 可以很容易做到保持原来文件的权限、时间、软硬链接等； 无须特殊权限即可安装； 优化的流程，文件传输效率高； 可以使用rsh、ssh等方式来传输文件，当然也可以通过直接的socket连接； 支持匿名传输。 最重要的是增量备份，即每次只更新变化的那部分。 ","date":"2022-02-09","objectID":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/:1:0","tags":null,"title":"Linux文件系统的备份","uri":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"基本用法 ","date":"2022-02-09","objectID":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/:2:0","tags":null,"title":"Linux文件系统的备份","uri":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"1 -r 参数 本机使用 rsync 命令时，可以作为cp和mv命令的替代方法，将源目录同步到目标目录。 $ rsync -r source destination 上面命令中，-r表示递归，即包含子目录。注意，-r是必须的，否则 rsync 运行不会成功。source目录表示源目录，destination表示目标目录。 如果有多个文件或目录需要同步，可以写成下面这样。 $ rsync -r source1 source2 destination 上面命令中，source1、source2都会被同步到destination目录。 ","date":"2022-02-09","objectID":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/:2:1","tags":null,"title":"Linux文件系统的备份","uri":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"2 -a 参数 -a参数可以替代-r，除了可以递归同步以外，还可以同步元信息（比如修改时间、权限等）。由于 rsync 默认使用文件大小和修改时间决定文件是否需要更新，所以-a比-r更有用。下面的用法才是常见的写法。 $ rsync -a source destination 目标目录destination如果不存在，rsync 会自动创建。执行上面的命令后，源目录source被完整地复制到了目标目录destination下面，即形成了destination/source的目录结构。 如果只想同步源目录source里面的内容到目标目录destination，则需要在源目录后面加上斜杠。 $ rsync -a source/ destination 上面命令执行后，source目录里面的内容，就都被复制到了destination目录里面，并不会在destination下面创建一个source子目录。 ","date":"2022-02-09","objectID":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/:2:2","tags":null,"title":"Linux文件系统的备份","uri":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"3 -n 参数 如果不确定 rsync 执行后会产生什么结果，可以先用-n或--dry-run参数模拟执行的结果。 $ rsync -anv source/ destination 上面命令中，-n参数模拟命令执行的结果，并不真的执行命令。-v参数则是将结果输出到终端，这样就可以看到哪些内容会被同步。 ","date":"2022-02-09","objectID":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/:2:3","tags":null,"title":"Linux文件系统的备份","uri":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"4 --delete 参数 默认情况下，rsync 只确保源目录的所有内容（明确排除的文件除外）都复制到目标目录。它不会使两个目录保持相同，并且不会删除文件。如果要使得目标目录成为源目录的镜像副本，则必须使用--delete参数，这将删除只存在于目标目录、不存在于源目录的文件。 $ rsync -av --delete source/ destination 上面命令中，--delete参数会使得destination成为source的一个镜像。 ","date":"2022-02-09","objectID":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/:2:4","tags":null,"title":"Linux文件系统的备份","uri":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"排除文件 ","date":"2022-02-09","objectID":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/:3:0","tags":null,"title":"Linux文件系统的备份","uri":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"1 --exclude 参数 有时，我们希望同步时排除某些文件或目录，这时可以用--exclude参数指定排除模式。 $ rsync -av --exclude='*.txt' source/ destination # 或者 $ rsync -av --exclude '*.txt' source/ destination 上面命令排除了所有 TXT 文件。 注意，rsync 会同步以\"点\"开头的隐藏文件，如果要排除隐藏文件，可以这样写--exclude=\".*\"。 如果要排除某个目录里面的所有文件，但不希望排除目录本身，可以写成下面这样。 $ rsync -av --exclude 'dir1/*' source/ destination 多个排除模式，可以用多个--exclude参数。 $ rsync -av --exclude 'file1.txt' --exclude 'dir1/*' source/ destination 多个排除模式也可以利用 Bash 的大扩号的扩展功能，只用一个--exclude参数。 $ rsync -av --exclude={'file1.txt','dir1/*'} source/ destination 如果排除模式很多，可以将它们写入一个文件，每个模式一行，然后用--exclude-from参数指定这个文件。 $ rsync -av --exclude-from='exclude-file.txt' source/ destination ","date":"2022-02-09","objectID":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/:3:1","tags":null,"title":"Linux文件系统的备份","uri":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"2 --include 参数 --include参数用来指定必须同步的文件模式，往往与--exclude结合使用。 $ rsync -av --include=\"*.txt\" --exclude='*' source/ destination 上面命令指定同步时，排除所有文件，但是会包括 TXT 文件。 ","date":"2022-02-09","objectID":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/:3:2","tags":null,"title":"Linux文件系统的备份","uri":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"远程同步 ","date":"2022-02-09","objectID":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/:4:0","tags":null,"title":"Linux文件系统的备份","uri":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"1 SSH 协议 rsync 除了支持本地两个目录之间的同步，也支持远程同步。它可以将本地内容，同步到远程服务器。 $ rsync -av source/ username@remote_host:destination 也可以将远程内容同步到本地。 $ rsync -av username@remote_host:source/ destination rsync 默认使用 SSH 进行远程登录和数据传输。 由于早期 rsync 不使用 SSH 协议，需要用-e参数指定协议，后来才改的。所以，下面-e ssh可以省略。 $ rsync -av -e ssh source/ user@remote_host:/destination 但是，如果 ssh 命令有附加的参数，则必须使用-e参数指定所要执行的 SSH 命令。 $ rsync -av -e 'ssh -p 2234' source/ user@remote_host:/destination 上面命令中，-e参数指定 SSH 使用2234端口。 ","date":"2022-02-09","objectID":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/:4:1","tags":null,"title":"Linux文件系统的备份","uri":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"2 rsync 协议 除了使用 SSH，如果另一台服务器安装并运行了 rsync 守护程序，则也可以用rsync://协议（默认端口873）进行传输。具体写法是服务器与目标目录之间使用双冒号分隔::。 $ rsync -av source/ 192.168.122.32::module/destination 注意，上面地址中的module并不是实际路径名，而是 rsync 守护程序指定的一个资源名，由管理员分配。 如果想知道 rsync 守护程序分配的所有 module 列表，可以执行下面命令。 $ rsync rsync://192.168.122.32 rsync 协议除了使用双冒号，也可以直接用rsync://协议指定地址。 $ rsync -av source/ rsync://192.168.122.32/module/destination ","date":"2022-02-09","objectID":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/:4:2","tags":null,"title":"Linux文件系统的备份","uri":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"源目录后面无 “/“ 和有 “/“ 的区别 将 /etc/yum 目录复制到 /tmp/zhang/ 目录下。 1 # 源目录后面无 \"/\" 2 [yun@backup ~]$ rsync -avz /etc/yum /tmp/zhang/ 3 [yun@backup ~]$ ll /tmp/zhang/ 4 total 0 5 drwxr-xr-x 6 yun yun 100 Nov 14 2018 yum 将 /etc/yum/ 目录下的所有文件和目录，复制到 /tmp/zhang/ 目录下。 1 # 源目录后面有 \"/\" 2 [yun@backup ~]$ rsync -avz /etc/yum/ /tmp/zhang/ 3 [yun@backup ~]$ ll /tmp/zhang/ 4 total 4 5 drwxr-xr-x 2 yun yun 6 Apr 13 2018 fssnap.d 6 drwxr-xr-x 2 yun yun 54 Nov 14 2018 pluginconf.d 7 drwxr-xr-x 2 yun yun 26 Nov 14 2018 protected.d 8 drwxr-xr-x 2 yun yun 37 Apr 13 2018 vars 9 -rw-r--r-- 1 yun yun 444 Apr 13 2018 version-groups.conf ","date":"2022-02-09","objectID":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/:5:0","tags":null,"title":"Linux文件系统的备份","uri":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"七、配置项 -a、--archive参数表示存档模式，保存所有的元数据，比如修改时间（modification time）、权限、所有者等，并且软链接也会同步过去。 --append参数指定文件接着上次中断的地方，继续传输。 --append-verify参数跟--append参数类似，但会对传输完成后的文件进行一次校验。如果校验失败，将重新发送整个文件。 -b、--backup参数指定在删除或更新目标目录已经存在的文件时，将该文件更名后进行备份，默认行为是删除。更名规则是添加由--suffix参数指定的文件后缀名，默认是~。 --backup-dir参数指定文件备份时存放的目录，比如--backup-dir=/path/to/backups。 --bwlimit参数指定带宽限制，默认单位是 KB/s，比如--bwlimit=100。 -c、--checksum参数改变rsync的校验方式。默认情况下，rsync 只检查文件的大小和最后修改日期是否发生变化，如果发生变化，就重新传输；使用这个参数以后，则通过判断文件内容的校验和，决定是否重新传输。 --delete参数删除只存在于目标目录、不存在于源目标的文件，即保证目标目录是源目标的镜像。 -e参数指定使用 SSH 协议传输数据。 --exclude参数指定排除不进行同步的文件，比如--exclude=\"*.iso\"。 --exclude-from参数指定一个本地文件，里面是需要排除的文件模式，每个模式一行。 --existing、--ignore-non-existing参数表示不同步目标目录中不存在的文件和目录。 -h参数表示以人类可读的格式输出。 -h、--help参数返回帮助信息。 -i参数表示输出源目录与目标目录之间文件差异的详细情况。 --ignore-existing参数表示只要该文件在目标目录中已经存在，就跳过去，不再同步这些文件。 --include参数指定同步时要包括的文件，一般与--exclude结合使用。 --link-dest参数指定增量备份的基准目录。 -m参数指定不同步空目录。 --max-size参数设置传输的最大文件的大小限制，比如不超过200KB（--max-size='200k'）。 --min-size参数设置传输的最小文件的大小限制，比如不小于10KB（--min-size=10k）。 -n参数或--dry-run参数模拟将要执行的操作，而并不真的执行。配合-v参数使用，可以看到哪些内容会被同步过去。 -P参数是--progress和--partial这两个参数的结合。 --partial参数允许恢复中断的传输。不使用该参数时，rsync会删除传输到一半被打断的文件；使用该参数后，传输到一半的文件也会同步到目标目录，下次同步时再恢复中断的传输。一般需要与--append或--append-verify配合使用。 --partial-dir参数指定将传输到一半的文件保存到一个临时目录，比如--partial-dir=.rsync-partial。一般需要与--append或--append-verify配合使用。 --progress参数表示显示进展。 -r参数表示递归，即包含子目录。 --remove-source-files参数表示传输成功后，删除发送方的文件。 --size-only参数表示只同步大小有变化的文件，不考虑文件修改时间的差异。 --suffix参数指定文件名备份时，对文件名添加的后缀，默认是~。 -u、--update参数表示同步时跳过目标目录中修改时间更新的文件，即不同步这些有更新的时间戳的文件。 -v参数表示输出细节。-vv表示输出更详细的信息，-vvv表示输出最详细的信息。 --version参数返回 rsync 的版本。 -z参数指定同步时压缩数据。 还好去年双十一购买的云服务器还有一部分磁盘空间可以使用。按照archwiki上的提示，备份整个系统只要 # rsync -aAXHv --exclude={\"/dev/*\",\"/proc/*\",\"/sys/*\",\"/tmp/*\",\"/run/*\",\"/mnt/*\",\"/media/*\",\"/lost+found\"} / /path/to/backup 通过使用 -aAX 选项集，文件以归档模式传输，确保符号链接、设备、权限、所有权、修改时间、ACLs和扩展属性得以保留，前提是目标文件系统支持这一功能。选项 -H 保留了硬链接，但会使用更多的内存。 --exclude 选项使符合给定模式的文件被排除。在上述命令中，/dev、proc、/sys、/tmp和/run 等目录被包括在内，但这些目录的内容被排除在外。这是因为它们在系统启动时才会被填入内容，但这些目录本身不会被创建。 /lost+found 是针对文件系统的。上面的命令依赖于 bash 和 zsh 中可用的括号扩展。当使用不同的 shell 时，应该手动重复 --exclude 模式。加入排除选项可以避免被 shell 误扩展，例如，在通过 SSH 备份时，这是必要的。以 * 结尾的排除路径可以确保目录本身在不存在的情况下被创建。 份，就像 cron 脚本一样。}} ","date":"2022-02-09","objectID":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/:6:0","tags":null,"title":"Linux文件系统的备份","uri":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"参考链接 https://www.ruanyifeng.com/blog/2020/08/rsync.html https://wiki.archlinux.org/title/Rsync_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%85%A8%E7%9B%98%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD ","date":"2022-02-09","objectID":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/:7:0","tags":null,"title":"Linux文件系统的备份","uri":"/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"关于 ","date":"2022-02-09","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"我的博客诞生史 ​ 从前我根本不知道博客对自己有什么用，我当时想博客应该和哪些自媒体一样，不论是分享生活还是技术，尽量增加曝光，获得一些人的关注的同时，甚至还会有额外收入。无论当时的我还是现在的我都觉得这基本是不可能的，我认为写博客不过是没啥事搞一搞自己的极客范。知道那天我看到的一篇文章上说，博客是向外输出自己的知识的过程， 这是写博客与写笔记的本质区别，其实我可能一直没有仔细思考过写博客这件事，当我真正写一些文章的时候，我发现我的表达能力这么不堪，可怕的是，这可能不止表现再“说”上面，当工作的时候就会发现，运用知识和表达某种程度上是一样的，都是知识输出的过程。如果逻辑不严谨，那么无论是说还是做都会七零八碎，以前在学校可能意识不到这一点，因为对于学生而言仅有的重要输出就是考试，很大概率上试卷上的内容会是书上的盖词填空。所以这缺少了练习准确输出知识的机会。也就是说之前的学习流程是不完善的，我目前（2022/4/19）认为：学习流程应该是这样的： 如果你要学习一个新知识（概念） 大量的收集信息（快速翻阅视频、书籍、博客、灵光一现） 归纳整理（记笔记、思维导图） 思考总结（用脑子） 输出（写文章、给别人讲一遍、动手做） 啊，给别人讲的这种方式其实有很多人说过，只是当时的我还不理解其中的意义也没有那么多给人讲的机会，这个过程好像修仙小说里的运功😅 有可能如果遇到复杂的知识点需要自己再输入一遍自己的输出（待研究） ​ 我的思维是这样的，我的知识是散的（做了笔记好很多）我的想法也是散的，我没有把这些知识或是想法组织起来，不能高效的存取（没有索引）结果就是没法对知识二次加工，没法发现想法与想法之间的关联。如果一直这样不改变，可能我学到的东西都是流于表面的。 ","date":"2022-02-09","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"不卑不亢，无欲则刚 ​ 至此，这句话成为了我的新的座右铭，曾经的是“尽人事，听天命”。现在看来这句话是后话了（人事也不是好尽的，只能听天命？）。 ​ 不卑不亢的本意是既不自卑，也不高傲。态度恰当，言行得体。可能更多的用在人际交往中（这也是我需要做到的），但是抽象一下概念，我理解的是人无论对人还是事都要保持一种适中的态度（所以这四个字是类的实例对象？），尤其在面对困难时，不要感到畏惧而逃避，面对简单的事，也不要感到轻松而不放在心上，其实这句话也曾经听过无数遍，今天只不过是从另一条路拐到这里。原来大道理都是相同的，说不定真有一天能让我找到一条无敌做人秘诀。 ​ 那么怎样做到不卑不亢呢？（理解不够深刻，待补充。。） ","date":"2022-02-09","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"}]